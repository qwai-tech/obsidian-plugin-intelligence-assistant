#!/usr/bin/env node

const { readFileSync, writeFileSync, existsSync } = require('fs');
const { join, dirname } = require('path');
const logger = require('./utils/logger');
const FileUtils = require('./utils/file-utils');

/**
 * Enhanced build script with analysis and better error handling
 */
class Builder {
    constructor() {
        this.sourceDir = process.cwd();
        this.isProduction = process.argv.includes('--production');
        this.analyze = process.argv.includes('--analyze');
        this.watch = process.argv.includes('--watch');
        this.skipTypeCheck = process.argv.includes('--skip-type-check');
        
        // Build configuration
        this.config = {
            entryPoint: 'main.ts',
            outputFile: 'main.js',
            externals: [
                'obsidian',
                'electron',
                '@codemirror/autocomplete',
                '@codemirror/collab',
                '@codemirror/commands',
                '@codemirror/language',
                '@codemirror/lint',
                '@codemirror/search',
                '@codemirror/state',
                '@codemirror/view',
                '@lezer/common',
                '@lezer/highlight',
                '@lezer/lr',
                'vm2',
                'isolated-vm'
            ]
        };
    }

    async build() {
        logger.section('ðŸ”¨ Build Process');
        
        try {
            // Step 1: Validate source files
            await this.validateSource();
            
            // Step 2: Run TypeScript check
            if (!this.skipTypeCheck) {
                await this.typeCheck();
            } else {
                logger.step('2', 'Skipping TypeScript type check');
            }
            
            // Step 3: Build with esbuild
            await this.runEsbuild();
            
            // Step 4: Analyze if requested
            if (this.analyze) {
                await this.analyzeBuild();
            }
            
            // Step 5: Start watch if requested
            if (this.watch) {
                await this.startWatch();
            } else {
                logger.success('âœ… Build completed successfully');
            }
            
        } catch (error) {
            logger.error(`Build failed: ${error.message}`);
            process.exit(1);
        } finally {
            // Ensure process exits properly for non-watch mode
            if (!this.watch) {
                setTimeout(() => {
                    process.exit(0);
                }, 100);
            }
        }
    }

    async validateSource() {
        logger.step('1', 'Validating source files');
        
        const entryPath = join(this.sourceDir, this.config.entryPoint);
        const packageJsonPath = join(this.sourceDir, 'package.json');
        const manifestJsonPath = join(this.sourceDir, 'manifest.json');
        
        const requiredFiles = [
            { path: this.config.entryPoint, name: 'Entry point' },
            { path: 'package.json', name: 'Package.json' },
            { path: 'manifest.json', name: 'Manifest' }
        ];
        
        for (const file of requiredFiles) {
            const info = FileUtils.getFileInfo(join(this.sourceDir, file.path));
            if (!info.exists) {
                throw new Error(`${file.name} not found: ${file.path}`);
            }
        }
        
        logger.success('Source files validated');
    }

    async typeCheck() {
        logger.step('2', 'Running TypeScript type check');
        
        const { execSync } = require('child_process');
        
        try {
            execSync('tsc --noEmit --skipLibCheck', { 
                stdio: 'pipe',
                cwd: this.sourceDir 
            });
            logger.success('TypeScript check passed');
        } catch (error) {
            logger.warning('TypeScript errors found (continuing build):');
            console.log(error.stdout.toString());
            // Don't fail the build, just warn about TypeScript errors
        }
    }

    async runEsbuild() {
        logger.step('3', 'Building with esbuild');
        
        const esbuild = require('esbuild');
        const builtins = require('builtin-modules');
        
        const banner = `
/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

        // CSS Plugin for inlining
        const cssPlugin = {
            name: 'css',
            setup(build) {
                build.onLoad({ filter: /\.css$/ }, async (args) => {
                    if (!existsSync(args.path)) {
                        logger.warning(`CSS file not found: ${args.path}`);
                        return { contents: 'export default "";', loader: 'js' };
                    }
                    
                    const css = readFileSync(args.path, 'utf8');
                    return {
                        contents: `
                            const css = ${JSON.stringify(css)};
                            if (typeof document !== 'undefined') {
                                const style = document.createElement('style');
                                style.textContent = css;
                                document.head.appendChild(style);
                            }
                            export default css;
                        `,
                        loader: 'js',
                    };
                });
            },
        };

        const sourceDir = this.sourceDir;
        const aliasPlugin = {
            name: 'alias-resolver',
            setup(build) {
                const fs = require('fs');
                const resolveWithExtensions = (basePath) => {
                    const extensions = ['', '.ts', '.tsx', '.js', '.jsx'];
                    for (const ext of extensions) {
                        const candidate = basePath + ext;
                        if (existsSync(candidate)) {
                            const stat = fs.statSync(candidate);
                            if (stat.isDirectory()) {
                                const indexCandidate = resolveWithExtensions(join(candidate, 'index'));
                                if (indexCandidate) {
                                    return indexCandidate;
                                }
                            } else {
                                return candidate;
                            }
                        }
                    }
                    return basePath;
                };

                build.onResolve({ filter: /^@plugin$/ }, () => ({
                    path: join(sourceDir, 'main.ts'),
                    namespace: 'file'
                }));

                build.onResolve({ filter: /^@\// }, (args) => {
                    const relativePath = args.path.slice(2); // remove '@/'
                    return {
                        path: resolveWithExtensions(join(sourceDir, 'src', relativePath)),
                        namespace: 'file'
                    };
                });
            }
        };

        try {
            const context = await esbuild.context({
                banner: {
                    js: banner,
                },
                entryPoints: [this.config.entryPoint],
                bundle: true,
                external: [...this.config.externals, ...(Array.isArray(builtins.default) ? builtins.default : builtins)],
                format: 'cjs',
                target: 'es2018',
                platform: 'node',
                logLevel: 'info',
                sourcemap: !this.isProduction,
                treeShaking: true,
                outfile: this.config.outputFile,
                plugins: [aliasPlugin, cssPlugin],
                minify: this.isProduction,
                define: this.isProduction ? {
                    'process.env.NODE_ENV': '"production"'
                } : undefined
            });

            if (this.watch) {
                logger.info('ðŸ‘€ Watching for changes...');
                await context.watch();
            } else {
                await context.rebuild();
                await context.dispose(); // Clean up esbuild context
                logger.success('esbuild completed');
            }
            
        } catch (error) {
            throw new Error(`esbuild failed: ${error.message}`);
        }
    }

    async analyzeBuild() {
        logger.step('4', 'Analyzing build output');
        
        const outputPath = join(this.sourceDir, this.config.outputFile);
        const info = FileUtils.getFileInfo(outputPath);
        
        if (!info.exists) {
            throw new Error('Build output not found');
        }
        
        logger.info(`ðŸ“Š Build Analysis:`);
        logger.info(`   Size: ${FileUtils.formatFileSize(info.size)}`);
        logger.info(`   Modified: ${info.modified.toLocaleString()}`);
        
        // Analyze dependencies if possible
        try {
            const content = readFileSync(outputPath, 'utf8');
            const requires = content.match(/require\(['"]([^'"]+)['"]\)/g) || [];
            const uniqueRequires = [...new Set(requires.map(r => r.replace(/require\(['"]|['"]\)/g, '')))];
            
            logger.info(`   Dependencies: ${uniqueRequires.length}`);
            if (uniqueRequires.length > 0) {
                logger.muted('   External modules:');
                uniqueRequires.slice(0, 10).forEach(dep => logger.muted(`     - ${dep}`));
                if (uniqueRequires.length > 10) {
                    logger.muted(`     ... and ${uniqueRequires.length - 10} more`);
                }
            }
        } catch (error) {
            logger.warning('Could not analyze dependencies');
        }
    }

    async startWatch() {
        logger.info('ðŸ‘€ Starting watch mode...');
        logger.info('ðŸ’¡ Press Ctrl+C to stop watching');
        
        // Watch mode is handled by esbuild context
        // Just keep the process alive
        process.on('SIGINT', () => {
            logger.info('\nðŸ‘‹ Watch mode stopped');
            process.exit(0);
        });
    }
}

// Command line interface
async function main() {
    const args = process.argv.slice(2);
    let showHelp = false;
    
    for (const arg of args) {
        if (arg === '--help' || arg === '-h') {
            showHelp = true;
        }
    }
    
    if (showHelp) {
        console.log(`
ðŸ”¨ Obsidian Plugin Build Tool

Usage: node build.js [options]

Options:
  --production       Build for production (minified, no sourcemaps)
  --watch            Start watch mode for development
  --analyze          Analyze build output (size, dependencies)
  --help             Show this help message

Examples:
  node build.js                    # Development build
  node build.js --production         # Production build
  node build.js --watch              # Watch mode
  node build.js --production --analyze # Production build with analysis

Configuration:
  Build options can be customized in scripts.config.js
        `);
        return;
    }
    
    const builder = new Builder();
    await builder.build();
}

// Run if called directly
if (require.main === module) {
    main().catch(error => {
        logger.error(`Unexpected error: ${error.message}`);
        process.exit(1);
    });
}

module.exports = Builder;
