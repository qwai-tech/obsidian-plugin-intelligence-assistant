/**
 * Workflow System V2 - Node Definitions
 *
 * Core node implementations for the workflow system.
 * Includes essential nodes for triggers, AI, data processing, and logic.
 */

import { NodeDef, NodeData, ExecutionContext } from '../core/types';
import { nodeRegistry } from './registry';

// ============================================================================
// TRIGGER NODES
// ============================================================================

/**
 * Start Node - Manual trigger to start workflow
 */
const startNode: NodeDef = {
	type: 'start',
	name: 'Start',
	icon: '‚ñ∂Ô∏è',
	color: '#22c55e',
	description: 'Manual trigger to start workflow',
	category: 'trigger',
	canBeStart: true,
	parameters: [
		{
			name: 'input',
			label: 'Input Data',
			type: 'json',
			default: '{}',
			description: 'Initial input data for the workflow (JSON format)',
		},
	],
	async execute(inputs, config, context) {
		try {
			// Parse input JSON
			const data = typeof config.input === 'string'
				? JSON.parse(config.input || '{}')
				: config.input || {};

			return [{ json: data }];
		} catch (error) {
			throw new Error(`Failed to parse input data: ${error.message}`);
		}
	},
};

// ============================================================================
// AI NODES
// ============================================================================

/**
 * LLM Chat Node - Generate text using AI
 */
const llmChatNode: NodeDef = {
	type: 'llm',
	name: 'AI Chat',
	icon: 'ü§ñ',
	color: '#3b82f6',
	description: 'Generate text using large language models',
	category: 'ai',
	parameters: [
		{
			name: 'model',
			label: 'Model',
			type: 'select',
			default: '', // Will be set dynamically to first available model,
			required: true,
			options: [
				{ label: 'GPT-4o', value: 'gpt-4o' },
				{ label: 'GPT-4o Mini', value: 'gpt-4o-mini' },
				{ label: 'Claude 3.5 Sonnet', value: 'claude-3-5-sonnet-20241022' },
				{ label: 'Claude 3.5 Haiku', value: 'claude-3-5-haiku-20241022' },
			],
			description: 'Select the AI model to use',
		},
		{
			name: 'prompt',
			label: 'Prompt',
			type: 'textarea',
			default: '',
			required: true,
			placeholder: 'Enter prompt...',
			description: 'Prompt to send to AI, use {{input}} to reference input data',
		},
		{
			name: 'systemPrompt',
			label: 'System Prompt',
			type: 'textarea',
			default: 'You are a helpful assistant.',
			placeholder: 'Enter system prompt...',
			description: 'Set the AI role and behavior',
		},
		{
			name: 'temperature',
			label: 'Temperature',
			type: 'number',
			default: 0.7,
			description: 'Control output randomness (0-2, higher = more random)',
		},
	],
	async execute(inputs, config, context) {
		const { model, prompt, systemPrompt, temperature } = config;

		// Get input text
		const inputText = inputs[0]?.json?.text || inputs[0]?.json?.input || '';

		// Replace {{input}} in prompt
		const finalPrompt = prompt.replace(/\{\{input\}\}/g, inputText);

		// Call AI service
		if (!context.services.ai) {
			throw new Error('AI service is not available');
		}

		try {
			const response = await context.services.ai.chat([
				{ role: 'system', content: systemPrompt },
				{ role: 'user', content: finalPrompt },
			], { model, temperature });

			return [{
				json: {
					response,
					model,
					prompt: finalPrompt,
				}
			}];
		} catch (error) {
			throw new Error(`AI call failed: ${error.message}`);
		}
	},
};

// ============================================================================
// DATA NODES
// ============================================================================

/**
 * Transform Node - Transform data using JavaScript
 */
const transformNode: NodeDef = {
	type: 'transform',
	name: 'Transform Data',
	icon: 'üîÑ',
	color: '#10b981',
	description: 'Transform data using JavaScript code',
	category: 'data',
	parameters: [
		{
			name: 'code',
			label: 'JavaScript Code',
			type: 'code',
			default: 'return input;',
			required: true,
			description: 'Transform function, use input to access input data, return transformed data',
		},
	],
	async execute(inputs, config, context) {
		const { code } = config;

		try {
			// Create function
			const fn = new Function('input', 'inputs', 'context', code);

			// Transform each input
			const results: NodeData[] = [];
			for (const input of inputs) {
				const result = fn(input.json, inputs, context);
				results.push({ json: result });
			}

			return results;
		} catch (error) {
			throw new Error(`Code execution failed: ${error.message}`);
		}
	},
};

/**
 * Filter Node - Filter data items
 */
const filterNode: NodeDef = {
	type: 'filter',
	name: 'Filter Data',
	icon: 'üîç',
	color: '#10b981',
	description: 'Filter data items by condition',
	category: 'data',
	parameters: [
		{
			name: 'condition',
			label: 'Filter Condition',
			type: 'code',
			default: 'return true;',
			required: true,
			description: 'Filter function, return true to keep, false to discard',
		},
	],
	async execute(inputs, config, context) {
		const { condition } = config;

		try {
			const fn = new Function('input', 'index', 'inputs', condition);

			const results = inputs.filter((input, index) => {
				try {
					return fn(input.json, index, inputs);
				} catch (error) {
					context.log(`Filter condition execution failed: ${error.message}`);
					return false;
				}
			});

			return results;
		} catch (error) {
			throw new Error(`Filter failed: ${error.message}`);
		}
	},
};

/**
 * Merge Node - Merge data from multiple inputs
 */
const mergeNode: NodeDef = {
	type: 'merge',
	name: 'Merge Data',
	icon: 'üîó',
	color: '#10b981',
	description: 'Merge data from multiple inputs',
	category: 'data',
	parameters: [
		{
			name: 'mode',
			label: 'Merge Mode',
			type: 'select',
			default: 'combine',
			options: [
				{ label: 'Combine All', value: 'combine' },
				{ label: 'Keep First', value: 'first' },
				{ label: 'Keep Last', value: 'last' },
			],
			description: 'How to merge multiple inputs',
		},
	],
	async execute(inputs, config, context) {
		const { mode } = config;

		switch (mode) {
			case 'first':
				return inputs.length > 0 ? [inputs[0]] : [{ json: {} }];

			case 'last':
				return inputs.length > 0 ? [inputs[inputs.length - 1]] : [{ json: {} }];

			case 'combine':
			default:
				return inputs.length > 0 ? inputs : [{ json: {} }];
		}
	},
};

// ============================================================================
// LOGIC NODES
// ============================================================================

/**
 * Condition Node - Conditional branching
 */
const conditionNode: NodeDef = {
	type: 'condition',
	name: 'Condition',
	icon: 'üîÄ',
	color: '#f59e0b',
	description: 'Conditional branching by condition',
	category: 'logic',
	parameters: [
		{
			name: 'condition',
			label: 'Condition',
			type: 'code',
			default: 'return input.value > 0;',
			required: true,
			description: 'Condition function, return true or false',
		},
	],
	async execute(inputs, config, context) {
		const { condition } = config;

		try {
			const fn = new Function('input', 'inputs', condition);

			// Evaluate condition on first input
			const input = inputs[0]?.json || {};
			const result = fn(input, inputs);

			return [{
				json: {
					...input,
					conditionResult: Boolean(result),
				}
			}];
		} catch (error) {
			throw new Error(`Condition evaluation failed: ${error.message}`);
		}
	},
};

// ============================================================================
// TOOL NODES
// ============================================================================

/**
 * Create Note Node - Create a note in Obsidian
 */
const createNoteNode: NodeDef = {
	type: 'createNote',
	name: 'Create Note',
	icon: 'üìù',
	color: '#8b5cf6',
	description: 'Create a new note in Obsidian',
	category: 'tools',
	parameters: [
		{
			name: 'path',
			label: 'Note Path',
			type: 'string',
			default: 'Untitled.md',
			required: true,
			placeholder: 'e.g., Notes/My Note.md',
			description: 'File path for the note',
		},
		{
			name: 'content',
			label: 'Note Content',
			type: 'textarea',
			default: '',
			required: true,
			placeholder: 'Enter note content...',
			description: 'Note content, use {{input}} to reference input data',
		},
	],
	async execute(inputs, config, context) {
		const { path, content } = config;

		// Replace {{input}} in content
		const inputText = inputs[0]?.json?.text || JSON.stringify(inputs[0]?.json || {});
		const finalContent = content.replace(/\{\{input\}\}/g, inputText);

		try {
			// Create note using Obsidian API
			const vault = context.services.vault;
			const file = await vault.create(path, finalContent);

			return [{
				json: {
					path: file.path,
					created: true,
					timestamp: Date.now(),
				}
			}];
		} catch (error) {
			throw new Error(`Note creation failed: ${error.message}`);
		}
	},
};

/**
 * HTTP Request Node - Make HTTP requests
 */
const httpRequestNode: NodeDef = {
	type: 'httpRequest',
	name: 'HTTP Request',
	icon: 'üåê',
	color: '#8b5cf6',
	description: 'Send HTTP requests',
	category: 'tools',
	parameters: [
		{
			name: 'url',
			label: 'URL',
			type: 'string',
			default: '',
			required: true,
			placeholder: 'https://api.example.com/data',
			description: 'Request URL',
		},
		{
			name: 'method',
			label: 'Request Method',
			type: 'select',
			default: 'GET',
			options: [
				{ label: 'GET', value: 'GET' },
				{ label: 'POST', value: 'POST' },
				{ label: 'PUT', value: 'PUT' },
				{ label: 'DELETE', value: 'DELETE' },
			],
			description: 'HTTP request method',
		},
		{
			name: 'body',
			label: 'Request Body',
			type: 'json',
			default: '{}',
			description: 'Request body for POST/PUT (JSON format)',
		},
	],
	async execute(inputs, config, context) {
		const { url, method, body } = config;

		if (!context.services.http) {
			throw new Error('HTTP service is not available');
		}

		try {
			const options: any = { method };

			if (method === 'POST' || method === 'PUT') {
				options.body = typeof body === 'string' ? body : JSON.stringify(body);
				options.headers = { 'Content-Type': 'application/json' };
			}

			const response = await context.services.http.request(url, options);

			return [{
				json: {
					status: response.status,
					data: response.data,
					url,
					method,
				}
			}];
		} catch (error) {
			throw new Error(`HTTP request failed: ${error.message}`);
		}
	},
};

// ============================================================================
// REGISTER ALL NODES
// ============================================================================

export function registerCoreNodes(): void {
	nodeRegistry.registerAll([
		// Triggers
		startNode,

		// AI
		llmChatNode,

		// Data
		transformNode,
		filterNode,
		mergeNode,

		// Logic
		conditionNode,

		// Tools
		createNoteNode,
		httpRequestNode,
	]);
}

// Note: Nodes are registered when initializeWorkflowSystem() is called
// This ensures proper initialization order
