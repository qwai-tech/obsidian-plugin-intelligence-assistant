import { ItemView, WorkspaceLeaf, Notice, Menu, TFile, TFolder, Modal, Setting } from 'obsidian';
import IntelligenceAssistantPlugin from '../../main';
import { Message, Attachment, FileReference } from '../llm/types';
import { ProviderFactory } from '../llm/provider-factory';
import { ModelManager } from '../llm/model-manager';
import { Conversation, ModelInfo, Agent, RAGConfig } from '../../main';
import { marked } from 'marked';
import { ToolManager } from '../tools/tool-manager';
import { ToolCall } from '../tools/types';
import { AgentMemoryManager } from '../memory/agent-memory';
import { RAGManager } from '../rag/rag-manager';
import { LLMConfig } from '../../main';
import { WebSearchService } from '../services/web-search-service';

export const CHAT_VIEW_TYPE = 'intelligence-assistant-chat';

export class ChatView extends ItemView {
	private plugin: IntelligenceAssistantPlugin;
	private messages: Message[] = [];
	private chatContainer: HTMLElement;
	private inputContainer: HTMLElement;
	private modelSelect: HTMLSelectElement;
	private availableModels: ModelInfo[] = [];
	private temperatureSlider: HTMLInputElement;
	private maxTokensInput: HTMLInputElement;
	private temperature: number = 0.7;
	private maxTokens: number = 4000;
	private conversationListContainer: HTMLElement;
	private mainChatContainer: HTMLElement;
	private currentConversationId: string | null = null;
	private modelCountEl: HTMLElement | null = null;
	private tokenSummaryEl: HTMLElement | null = null;
	private conversationListVisible: boolean = false;
	private conversationListPinned: boolean = false;
	private currentAttachments: Attachment[] = [];
	private attachmentContainer: HTMLElement | null = null;
	private referencedFiles: (TFile | TFolder)[] = [];
	private referenceContainer: HTMLElement | null = null;

	// Mode and options
	private mode: 'chat' | 'agent' = 'chat';
	private enableRAG: boolean = false;
	private enableWebSearch: boolean = false;
	private enableThink: boolean = false;
	private toolManager: ToolManager;
	private memoryManager: AgentMemoryManager;
	private ragManager: RAGManager;
	private webSearchService: WebSearchService;
	private ragToggleBtn: HTMLElement | null = null;

	// Streaming state
	private isStreaming: boolean = false;
	private stopStreamingRequested: boolean = false;
	private streamingMessageEl: HTMLElement | null = null;
	private stopBtn: HTMLElement | null = null;
	private sendHint: HTMLElement | null = null;

	constructor(leaf: WorkspaceLeaf, plugin: IntelligenceAssistantPlugin) {
		super(leaf);
		this.plugin = plugin;
		this.toolManager = new ToolManager(this.app, this.plugin.settings.builtInTools);
		this.memoryManager = new AgentMemoryManager(this.plugin.settings.agentMemories);
		this.ragManager = new RAGManager(this.app, this.plugin.settings.ragConfig, this.plugin.settings.llmConfigs);
		this.webSearchService = new WebSearchService(this.plugin.settings.webSearchConfig);
	}

	getViewType(): string {
		return CHAT_VIEW_TYPE;
	}

	getDisplayText(): string {
		return 'AI Chat';
	}

	getIcon(): string {
		return 'message-square';
	}

	async onOpen() {
		const container = this.containerEl.children[1];
		container.empty();
		container.addClass('intelligence-assistant-chat-container');

		// Create main layout with floating sidebar
		const mainLayout = container.createDiv('chat-main-layout');

		// Main chat container (full width)
		this.mainChatContainer = mainLayout.createDiv('main-chat-area');

		// Floating conversation list sidebar (hidden by default)
		this.conversationListContainer = mainLayout.createDiv('conversation-list-floating');
		this.conversationListContainer.style.display = 'none';
		this.renderConversationList();

		// Header
		const header = this.mainChatContainer.createDiv('chat-header');
		header.style.display = 'flex';
		header.style.gap = '12px';
		header.style.padding = '12px';
		header.style.borderBottom = '1px solid var(--background-modifier-border)';
		header.style.background = 'var(--background-secondary)';
		header.style.alignItems = 'center';

		// Toggle conversation list button
		const toggleConvBtn = header.createEl('button', { text: '‚ò∞' });
		toggleConvBtn.title = 'Toggle Conversations';
		toggleConvBtn.style.padding = '6px 12px';
		toggleConvBtn.style.borderRadius = '4px';
		toggleConvBtn.style.border = '1px solid var(--background-modifier-border)';
		toggleConvBtn.style.background = 'var(--background-primary)';
		toggleConvBtn.style.cursor = 'pointer';
		toggleConvBtn.style.fontSize = '16px';
		toggleConvBtn.addEventListener('click', (e) => {
			e.stopPropagation();
			this.toggleConversationList();
		});

		// Model selector (more prominent with better styling)
		const modelContainer = header.createDiv('model-selector');
		modelContainer.style.display = 'flex';
		modelContainer.style.alignItems = 'center';
		modelContainer.style.gap = '8px';
		modelContainer.style.flex = '1';

		const modelLabel = modelContainer.createSpan({ text: 'ü§ñ Model:' });
		modelLabel.style.fontWeight = '500';
		modelLabel.style.fontSize = '13px';

		this.modelSelect = modelContainer.createEl('select');
		this.modelSelect.style.flex = '1';
		this.modelSelect.style.padding = '6px 10px';
		this.modelSelect.style.borderRadius = '4px';
		this.modelSelect.style.border = '1px solid var(--background-modifier-border)';
		this.modelSelect.style.background = 'var(--background-primary)';
		this.modelSelect.style.color = 'var(--text-normal)';
		this.modelSelect.style.fontSize = '13px';
		this.modelSelect.style.cursor = 'pointer';
		this.modelSelect.addEventListener('change', () => this.onModelChange());

		// Quick actions for model
		const modelActions = header.createDiv();
		modelActions.style.display = 'flex';
		modelActions.style.gap = '6px';

		// Model count info
		this.modelCountEl = header.createSpan();
		this.modelCountEl.style.fontSize = '11px';
		this.modelCountEl.style.color = 'var(--text-muted)';
		this.modelCountEl.style.padding = '4px 8px';
		this.modelCountEl.style.background = 'var(--background-primary)';
		this.modelCountEl.style.borderRadius = '4px';
		this.modelCountEl.setText('Loading...');

		// Token usage summary
		this.tokenSummaryEl = header.createSpan();
		this.tokenSummaryEl.style.fontSize = '11px';
		this.tokenSummaryEl.style.color = 'var(--text-muted)';
		this.tokenSummaryEl.style.padding = '4px 8px';
		this.tokenSummaryEl.style.background = 'var(--background-primary)';
		this.tokenSummaryEl.style.borderRadius = '4px';
		this.tokenSummaryEl.style.marginLeft = '8px';
		this.tokenSummaryEl.setText('Tokens: 0');
		this.tokenSummaryEl.title = 'Total tokens used in this conversation';

		// New chat button
		const newChatBtn = modelActions.createEl('button', { text: '‚ûï New' });
		newChatBtn.title = 'New Chat';
		newChatBtn.style.padding = '6px 12px';
		newChatBtn.style.borderRadius = '4px';
		newChatBtn.style.border = '1px solid var(--background-modifier-border)';
		newChatBtn.style.background = 'var(--background-primary)';
		newChatBtn.style.cursor = 'pointer';
		newChatBtn.style.fontSize = '13px';
		newChatBtn.style.fontWeight = '500';
		newChatBtn.addEventListener('click', () => this.createNewConversation());

		// Settings button
		const settingsBtn = modelActions.createEl('button', { text: '‚öôÔ∏è' });
		settingsBtn.title = 'Open Settings';
		settingsBtn.style.padding = '6px 10px';
		settingsBtn.style.borderRadius = '4px';
		settingsBtn.style.border = '1px solid var(--background-modifier-border)';
		settingsBtn.style.background = 'var(--background-primary)';
		settingsBtn.style.cursor = 'pointer';
		settingsBtn.style.fontSize = '14px';
		settingsBtn.addEventListener('click', () => {
			// Open plugin settings
			// @ts-ignore - app.setting is available
			this.app.setting.open();
			// @ts-ignore - app.setting is available
			this.app.setting.openTabById('intelligence-assistant');
		});

		await this.refreshModels();

		// Set default model if configured
		if (this.plugin.settings.defaultModel && this.modelSelect.value === '') {
			this.modelSelect.value = this.plugin.settings.defaultModel;
		}
		
		// Update image button visibility based on the selected model's vision capability
		await this.updateImageButtonVisibility();

		// Parameters row (compact and styled)
		const paramsRow = this.mainChatContainer.createDiv('params-row');
		paramsRow.style.display = 'flex';
		paramsRow.style.gap = '16px';
		paramsRow.style.padding = '8px 12px';
		paramsRow.style.background = 'var(--background-primary)';
		paramsRow.style.borderBottom = '1px solid var(--background-modifier-border)';
		paramsRow.style.fontSize = '12px';
		paramsRow.style.alignItems = 'center';

		// Temperature control
		const tempContainer = paramsRow.createDiv('param-control');
		tempContainer.style.display = 'flex';
		tempContainer.style.alignItems = 'center';
		tempContainer.style.gap = '8px';

		const tempLabel = tempContainer.createSpan({ text: 'üå°Ô∏è Temperature:' });
		tempLabel.style.color = 'var(--text-muted)';
		tempLabel.style.fontWeight = '500';

		this.temperatureSlider = tempContainer.createEl('input', { type: 'range' });
		this.temperatureSlider.min = '0';
		this.temperatureSlider.max = '2';
		this.temperatureSlider.step = '0.1';
		this.temperatureSlider.value = this.temperature.toString();
		this.temperatureSlider.style.width = '100px';
		this.temperatureSlider.style.cursor = 'pointer';

		const tempValue = tempContainer.createSpan({ text: this.temperature.toString() });
		tempValue.style.minWidth = '30px';
		tempValue.style.fontWeight = '600';
		tempValue.style.color = 'var(--text-accent)';

		this.temperatureSlider.addEventListener('input', () => {
			this.temperature = parseFloat(this.temperatureSlider.value);
			tempValue.setText(this.temperature.toFixed(1));
		});

		// Max tokens control
		const tokensContainer = paramsRow.createDiv('param-control');
		tokensContainer.style.display = 'flex';
		tokensContainer.style.alignItems = 'center';
		tokensContainer.style.gap = '8px';

		const tokensLabel = tokensContainer.createSpan({ text: 'üìä Max Tokens:' });
		tokensLabel.style.color = 'var(--text-muted)';
		tokensLabel.style.fontWeight = '500';

		this.maxTokensInput = tokensContainer.createEl('input', { type: 'number' });
		this.maxTokensInput.min = '100';
		this.maxTokensInput.max = '100000';
		this.maxTokensInput.step = '100';
		this.maxTokensInput.value = this.maxTokens.toString();
		this.maxTokensInput.style.width = '80px';
		this.maxTokensInput.style.padding = '4px 8px';
		this.maxTokensInput.style.borderRadius = '4px';
		this.maxTokensInput.style.border = '1px solid var(--background-modifier-border)';
		this.maxTokensInput.style.background = 'var(--background-secondary)';
		this.maxTokensInput.style.fontSize = '12px';

		this.maxTokensInput.addEventListener('input', () => {
			const value = parseInt(this.maxTokensInput.value);
			if (!isNaN(value) && value > 0) {
				this.maxTokens = value;
			}
		});

		// Chat messages container
		this.chatContainer = this.mainChatContainer.createDiv('chat-messages');

		// Input container
		this.inputContainer = this.mainChatContainer.createDiv('chat-input-container');

		// Reference area with @ mentions
		this.referenceContainer = this.inputContainer.createDiv('input-reference-area');
		this.referenceContainer.style.display = 'none';

		const referenceList = this.referenceContainer.createDiv('reference-list');

		const addReferenceBtn = this.inputContainer.createDiv('add-reference-btn');
		addReferenceBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M16 12h-8M12 8v8"></path><circle cx="12" cy="12" r="10"></circle></svg> Add reference (@)`;
		addReferenceBtn.title = 'Add file or folder reference (@)';
		addReferenceBtn.addEventListener('click', () => this.showReferenceMenu());

		// Text input area
		const textarea = this.inputContainer.createEl('textarea', {
			attr: {
				placeholder: 'Type your message... (Enter to send, Shift+Enter for new line)',
				rows: '1'
			}
		});
		textarea.addClass('chat-input');

		// Auto-resize textarea
		textarea.addEventListener('input', () => {
			textarea.style.height = 'auto';
			textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
		});

		// Bottom - Controls (mode selector, options, image, send)
		const bottomControls = this.inputContainer.createDiv('input-bottom-controls');

		// Left section - Mode selector, prompt selector, and options
		const leftControls = bottomControls.createDiv('bottom-left-controls');

		// Mode/Agent selector
		const modeSelector = leftControls.createEl('select');
		modeSelector.addClass('mode-selector');

		// Build options: Chat, Agent, Workflows
		let options = `
			<option value="chat">üí¨ Chat</option>
			<option value="agent">üõ†Ô∏è Agent (Tools)</option>
		`;

		// Add configured agents
		const agents = this.plugin.settings.agents;
		if (agents.length > 0) {
			options += '<option disabled>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</option>';
			for (const agent of agents) {
				options += `<option value="agent:${agent.id}">${agent.icon || 'ü§ñ'} ${agent.name}</option>`;
			}
		}

		// Add configured workflows from vault files
		const { WorkflowFileManager } = await import('../workflows/workflow-file-manager');
		const workflowManager = new WorkflowFileManager(this.app);
		const workflowFiles = await workflowManager.getAllWorkflowFiles();

		if (workflowFiles.length > 0) {
			options += '<option disabled>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</option>';
			for (const file of workflowFiles) {
				const workflow = await workflowManager.loadWorkflowFromFile(file);
				if (workflow) {
					options += `<option value="workflow:${file.path}">${workflow.icon || '‚öôÔ∏è'} ${workflow.name}</option>`;
				}
			}
		}

		modeSelector.innerHTML = options;

		// Set current value
		if (this.plugin.settings.activeAgentId && this.mode === 'agent') {
			modeSelector.value = `agent:${this.plugin.settings.activeAgentId}`;
		} else {
			modeSelector.value = this.mode;
		}

		modeSelector.addEventListener('change', async () => {
			const value = modeSelector.value;
			if (value.startsWith('agent:')) {
				this.mode = 'agent';
				const agentId = value.substring(6);
				this.plugin.settings.activeAgentId = agentId;
				await this.plugin.saveSettings();
				// Apply agent configuration
				await this.applyAgentConfig(agentId);
			} else if (value.startsWith('workflow:')) {
				const workflowPath = value.substring(9);
				this.plugin.settings.activeAgentId = null;
				await this.plugin.saveSettings();
				// Execute workflow
				this.executeWorkflow(workflowPath);
			} else {
				this.mode = value as 'chat' | 'agent';
				if (value === 'chat') {
					this.plugin.settings.activeAgentId = null;
					await this.plugin.saveSettings();
				} else if (value === 'agent') {
					// For generic agent mode, enable think mode by default
					this.enableThink = true;
					this.plugin.settings.activeAgentId = null;
					await this.plugin.saveSettings();
				}
			}
			this.updateOptionsDisplay();
		});

		// Prompt selector
		const promptSelector = leftControls.createEl('select');
		promptSelector.addClass('prompt-selector');
		promptSelector.style.marginLeft = '8px';
		const enabledPrompts = this.plugin.settings.systemPrompts.filter(p => p.enabled);
		promptSelector.innerHTML = '<option value="">No System Prompt</option>' +
			enabledPrompts.map(p =>
				`<option value="${p.id}" ${this.plugin.settings.activeSystemPromptId === p.id ? 'selected' : ''}>${p.name}</option>`
			).join('');
		promptSelector.addEventListener('change', async () => {
			this.plugin.settings.activeSystemPromptId = promptSelector.value || null;
			await this.plugin.saveSettings();
		});

		// Options container
		const optionsContainer = leftControls.createDiv('mode-options');

		// Chat mode options - beautiful toggle buttons
		const chatOptions = optionsContainer.createDiv('chat-mode-options');

		// Create toggle buttons with settings checks
		this.ragToggleBtn = this.createToggleButton(chatOptions, {
			icon: 'üìö',
			label: 'RAG',
			active: this.enableRAG && this.plugin.settings.ragConfig.enabled,
			disabled: !this.plugin.settings.ragConfig.enabled,
			disabledMessage: 'RAG is disabled in settings. Enable it in Settings > Chat Features > RAG',
			onChange: (active) => { this.enableRAG = active; }
		});
		
		// Update RAG button with statistics
		this.updateRagStatus(this.ragToggleBtn);

		const webSearchToggle = this.createToggleButton(chatOptions, {
			icon: 'üîç',
			label: 'Web',
			active: this.enableWebSearch && this.plugin.settings.webSearchConfig.enabled,
			disabled: !this.plugin.settings.webSearchConfig.enabled,
			disabledMessage: 'Web Search is disabled in settings. Enable it in Settings > Chat Features > Web Search',
			onChange: (active) => { this.enableWebSearch = active; }
		});



		// Agent mode options - show available tools
		const agentOptions = optionsContainer.createDiv('agent-mode-options');
		agentOptions.style.display = 'none';

		const toolsLabel = agentOptions.createSpan();
		toolsLabel.setText(`üõ†Ô∏è ${this.toolManager.getAllTools().length} tools`);
		toolsLabel.addClass('tools-label');

		// Middle section - Add image button (only for chat mode)
		const middleControls = bottomControls.createDiv('bottom-middle-controls');

		const addImageBtn = middleControls.createEl('button');
		addImageBtn.addClass('input-control-btn');
		addImageBtn.addClass('image-btn');
		addImageBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>`;
		addImageBtn.title = 'Attach Image';
		addImageBtn.style.display = this.mode === 'chat' ? 'flex' : 'none'; // Only show in chat mode initially, vision capability checked separately
		addImageBtn.addEventListener('click', (e) => {
			e.preventDefault();
			this.attachImage();
		});

		// Attachment preview area
		this.attachmentContainer = middleControls.createDiv('attachment-preview');
		this.attachmentContainer.style.display = 'none';

		// Right section - Send info and stop button
		const rightControls = bottomControls.createDiv('bottom-right-controls');

		// Send hint
		this.sendHint = rightControls.createEl('span');
		this.sendHint.style.fontSize = '11px';
		this.sendHint.style.color = 'var(--text-muted)';
		this.sendHint.innerHTML = 'Press <kbd>Enter</kbd> to send';

		// Stop generation button (hidden by default)
		this.stopBtn = rightControls.createEl('button', { cls: 'stop-generation-btn' });
		this.stopBtn.innerHTML = '‚èπÔ∏è Stop';
		this.stopBtn.style.display = 'none';
		this.stopBtn.addEventListener('click', () => {
			this.stopStreamingRequested = true;
			if (this.stopBtn) this.stopBtn.style.display = 'none';
			if (this.sendHint) this.sendHint.style.display = 'block';
			new Notice('Stopping generation...');
		});

		const sendMessage = async () => {
			const text = textarea.value.trim();
			if (!text && this.currentAttachments.length === 0 && this.referencedFiles.length === 0) return;

			textarea.value = '';
			textarea.style.height = 'auto';
			await this.sendMessage(text);
			// Clear attachments and references after sending
			this.currentAttachments = [];
			this.referencedFiles = [];
			this.updateAttachmentPreview();
			this.updateReferenceDisplay();
		};

		textarea.addEventListener('keydown', (e) => {
			if (e.key === 'Enter' && !e.shiftKey) {
				e.preventDefault();
				sendMessage();
			}
		});

		// Add styles
		this.addStyles();

		// Add click-outside handler to hide conversation list
		this.registerDomEvent(document, 'click', (e: MouseEvent) => {
			// Only hide if not pinned and currently visible
			if (!this.conversationListPinned && this.conversationListVisible) {
				const target = e.target as HTMLElement;
				// Check if click is outside conversation list
				if (!this.conversationListContainer.contains(target)) {
					this.conversationListVisible = false;
					this.conversationListContainer.style.display = 'none';
				}
			}
		});

		// Always initialize RAG manager to load existing data from storage for status display
		// This ensures the status shows correctly even when RAG is not enabled for search
		try {
			await this.ragManager.updateConfig(this.plugin.settings.ragConfig);
			await this.ragManager.initialize();
			
			// Update RAG status after initialization completes
			if (this.ragToggleBtn) {
				await this.updateRagStatus(this.ragToggleBtn);
			}
		} catch (error) {
			console.error('Error initializing RAG:', error);
			new Notice(`RAG initialization error: ${error.message}`);
		}

		// Initialize RAG if enabled for actual search functionality
		if (this.enableRAG && this.plugin.settings.ragConfig.enabled) {
			// RAG manager is already initialized above, so we can proceed with search functionality
		}

		// Load or create initial conversation
		await this.loadOrCreateConversation();
	}

	private renderConversationList() {
		this.conversationListContainer.empty();

		// Header with new conversation button and pin button
		const listHeader = this.conversationListContainer.createDiv('conversation-list-header');
		listHeader.createEl('h3', { text: 'Conversations' });

		const headerButtons = listHeader.createDiv('conversation-header-buttons');
		headerButtons.style.display = 'flex';
		headerButtons.style.gap = '4px';

		// Pin/Unpin button
		const pinBtn = headerButtons.createEl('button', { text: this.conversationListPinned ? 'üìå' : 'üìç' });
		pinBtn.addClass('pin-conversation-btn');
		pinBtn.title = this.conversationListPinned ? 'Unpin' : 'Pin to sidebar';
		pinBtn.addEventListener('click', () => this.togglePinConversationList());

		const newConvBtn = headerButtons.createEl('button', { text: '+' });
		newConvBtn.addClass('new-conversation-btn');
		newConvBtn.title = 'New Conversation';
		newConvBtn.addEventListener('click', () => this.createNewConversation());

		// Conversation list
		const listContent = this.conversationListContainer.createDiv('conversation-list-content');

		const conversations = this.plugin.settings.conversations;
		if (conversations.length === 0) {
			listContent.createDiv('empty-state').setText('No conversations yet');
			return;
		}

		conversations.forEach(conv => {
			const convItem = listContent.createDiv('conversation-item');
			convItem.style.display = 'flex';
			convItem.style.alignItems = 'center';
			convItem.style.justifyContent = 'space-between';
			convItem.style.gap = '8px';
			convItem.style.padding = '8px 12px';
			convItem.style.cursor = 'pointer';
			convItem.style.borderRadius = '4px';

			if (conv.id === this.currentConversationId) {
				convItem.addClass('active');
				convItem.style.background = 'var(--background-modifier-hover)';
			}

			const convTitle = convItem.createDiv('conversation-title');
			convTitle.style.flex = '1';
			convTitle.style.overflow = 'hidden';
			convTitle.style.textOverflow = 'ellipsis';
			convTitle.style.whiteSpace = 'nowrap';

			// Add icon if enabled and available
			if (this.plugin.settings.conversationIconEnabled && conv.icon) {
				const icon = convTitle.createSpan('conversation-icon');
				icon.setText(conv.icon + ' ');
			}

			convTitle.createSpan().setText(conv.title);
			convTitle.addEventListener('click', () => this.switchConversation(conv.id));

			// Actions container
			const actions = convItem.createDiv('conversation-actions');
			actions.style.display = 'flex';
			actions.style.gap = '4px';
			actions.style.opacity = '0';
			actions.style.transition = 'opacity 0.2s';

			// Show actions on hover
			convItem.addEventListener('mouseenter', () => {
				actions.style.opacity = '1';
			});
			convItem.addEventListener('mouseleave', () => {
				actions.style.opacity = '0';
			});

			// Delete button
			const deleteBtn = actions.createEl('button', { text: 'üóëÔ∏è' });
			deleteBtn.title = 'Delete';
			deleteBtn.style.padding = '4px 6px';
			deleteBtn.style.fontSize = '12px';
			deleteBtn.style.border = 'none';
			deleteBtn.style.background = 'transparent';
			deleteBtn.style.cursor = 'pointer';
			deleteBtn.style.borderRadius = '3px';
			deleteBtn.style.color = 'var(--text-error)';
			deleteBtn.addEventListener('click', (e) => {
				e.stopPropagation();
				this.deleteConversation(conv.id);
			});

			// Context menu for additional options
			convItem.addEventListener('contextmenu', (e) => {
				e.preventDefault();
				const menu = new Menu();

				menu.addItem((item) => {
					item.setTitle('Delete')
						.setIcon('trash')
						.onClick(() => this.deleteConversation(conv.id));
				});

				menu.showAtMouseEvent(e);
			});
		});
	}

	private toggleConversationList() {
		this.conversationListVisible = !this.conversationListVisible;
		if (this.conversationListVisible) {
			this.conversationListContainer.style.display = 'flex';
		} else {
			this.conversationListContainer.style.display = 'none';
		}
	}

	private togglePinConversationList() {
		this.conversationListPinned = !this.conversationListPinned;
		this.updateConversationListStyle();
		this.renderConversationList();
	}

	private updateConversationListStyle() {
		if (this.conversationListPinned) {
			// Pinned mode: fixed sidebar
			this.conversationListContainer.style.position = 'relative';
			this.conversationListContainer.style.boxShadow = 'none';
			this.conversationListVisible = true;
			this.conversationListContainer.style.display = 'flex';
		} else {
			// Floating mode: overlay
			this.conversationListContainer.style.position = 'absolute';
			this.conversationListContainer.style.boxShadow = '2px 0 8px rgba(0, 0, 0, 0.1)';
		}
	}

	private async loadOrCreateConversation() {
		// Try to load active conversation
		if (this.plugin.settings.activeConversationId) {
			const conv = this.plugin.settings.conversations.find(
				c => c.id === this.plugin.settings.activeConversationId
			);
			if (conv) {
				this.loadConversation(conv);
				return;
			}
		}

		// Try to load most recent conversation
		if (this.plugin.settings.conversations.length > 0) {
			const mostRecent = this.plugin.settings.conversations
				.sort((a, b) => b.updatedAt - a.updatedAt)[0];
			this.loadConversation(mostRecent);
			return;
		}

		// Create new conversation
		await this.createNewConversation();
	}

	private async createNewConversation() {
		const newConv: Conversation = {
			id: Date.now().toString(),
			title: 'New Conversation',
			messages: [],
			createdAt: Date.now(),
			updatedAt: Date.now(),
		};

		this.plugin.settings.conversations.push(newConv);
		this.plugin.settings.activeConversationId = newConv.id;
		await this.plugin.saveSettings();

		this.loadConversation(newConv);
		this.renderConversationList();
		// Close conversation list after creating new conversation (only if not pinned)
		if (!this.conversationListPinned) {
			this.conversationListVisible = false;
			this.conversationListContainer.style.display = 'none';
		}
	}

	private loadConversation(conv: Conversation) {
		this.currentConversationId = conv.id;
		this.messages = conv.messages;
		this.plugin.settings.activeConversationId = conv.id;

		// Re-render messages
		this.chatContainer.empty();
		this.messages.forEach(msg => this.addMessageToUI(msg));

		// Update token summary after loading conversation
		this.updateTokenSummary();

		this.renderConversationList();
	}

	private async switchConversation(convId: string) {
		// Save current conversation before switching (skip re-render to avoid double render)
		await this.saveCurrentConversation(true);

		const conv = this.plugin.settings.conversations.find(c => c.id === convId);
		if (conv) {
			this.loadConversation(conv);
			await this.plugin.saveSettings();
			// Close conversation list after switching (only if not pinned)
			if (!this.conversationListPinned) {
				this.conversationListVisible = false;
				this.conversationListContainer.style.display = 'none';
			}
		}
	}

	private async saveCurrentConversation(skipRender: boolean = false) {
		if (!this.currentConversationId) return;

		const convIndex = this.plugin.settings.conversations.findIndex(
			c => c.id === this.currentConversationId
		);

		if (convIndex === -1) {
			console.error('Could not find conversation to save:', this.currentConversationId);
			return;
		}

		const originalConv = this.plugin.settings.conversations[convIndex];
		const conv = { ...originalConv }; // Create a shallow copy

		// Filter out system messages before saving
		conv.messages = this.messages.filter(m => m.role !== 'system') as Array<{ role: 'user' | 'assistant'; content: string; model?: string }>;
		conv.updatedAt = Date.now();

		// Auto-generate/update title based on settings (only once for new conversations)
		const shouldUpdateTitle = this.shouldUpdateConversationTitle(conv);
		if (shouldUpdateTitle) {
			const newTitle = await this.generateConversationTitle(conv);
			if (newTitle) {
				conv.title = newTitle;
				if (this.plugin.settings.conversationIconEnabled && !conv.icon) {
					const newIcon = await this.generateConversationIcon(newTitle);
					if (newIcon) {
						conv.icon = newIcon;
					}
				}
			}
		}

		// Replace the old conversation object with the updated one
		this.plugin.settings.conversations[convIndex] = conv;

		await this.plugin.saveSettings();

		// Only re-render if not skipped (e.g., when switching conversations)
		if (!skipRender) {
			this.renderConversationList();
		}
	}

	private shouldUpdateConversationTitle(conv: Conversation): boolean {
		// Only generate title once for "New Conversation" with at least 2 messages
		if (conv.title === 'New Conversation' && this.messages.length >= 2) {
			return true;
		}

		// Never auto-update after initial generation
		return false;
	}

	private async generateConversationTitle(conv: Conversation): Promise<string | null> {
		const mode = this.plugin.settings.conversationTitleMode;

		if (mode === 'first-message') {
			const firstUserMsg = this.messages.find(m => m.role === 'user');
			if (firstUserMsg) {
				return firstUserMsg.content.substring(0, 50) + (firstUserMsg.content.length > 50 ? '...' : '');
			}
		} else if (mode === 'llm-summary') {
			try {
				const titleModel = this.plugin.settings.titleSummaryModel || this.modelSelect.value;
				if (!titleModel) return null;

				const config = ModelManager.findConfigForModelByProvider(titleModel, this.plugin.settings.llmConfigs);
				if (!config) return null;

				let contextMessages: Message[];
				if (this.messages.length <= 4) {
					contextMessages = this.messages.slice(0, 4);
				} else {
					const first = this.messages.slice(0, 2);
					const last = this.messages.slice(-2);
					contextMessages = [...first, ...last];
				}

				const conversationText = contextMessages
					.map(m => `${m.role}: ${m.content.substring(0, 200)}`)
					.join('\n\n');

				const promptTemplate = this.plugin.settings.titleSummaryPrompt ||
					'Generate a short, descriptive title (max 6 words) for this conversation:\n\n{conversation}\n\nTitle:';
				const prompt = promptTemplate.replace('{conversation}', conversationText);

				const modelConfig = { ...config, model: titleModel, temperature: 0.3 };
				const provider = ProviderFactory.createProvider(modelConfig);

				const response = await provider.chat({
					messages: [{ role: 'user', content: prompt }],
					model: titleModel,
					temperature: 0.3
				});

				let title = response.content.trim().replace(/^["']|["']$/g, '').replace(/^Title:\s*/i, '');

				if (title.length > 0 && title.length <= 100) {
					return title;
				}
			} catch (error) {
				console.error('Failed to generate LLM title:', error);
			}
		}

		// Fallback to first message if LLM summary fails or is not enabled
		const firstUserMsg = this.messages.find(m => m.role === 'user');
		if (firstUserMsg) {
			return firstUserMsg.content.substring(0, 50) + (firstUserMsg.content.length > 50 ? '...' : '');
		}

		return 'New Conversation'; // Should not happen if there are messages
	}

	private async generateConversationIcon(title: string): Promise<string | null> {
		try {
			const modelId = this.plugin.settings.titleSummaryModel || this.modelSelect.value;
			if (!modelId) return null;

			const config = ModelManager.findConfigForModelByProvider(modelId, this.plugin.settings.llmConfigs);
			if (!config) return null;

			const modelConfig = { ...config, model: modelId, temperature: 0.5 };
			const provider = ProviderFactory.createProvider(modelConfig);

			const response = await provider.chat({
				messages: [
					{
						role: 'user',
						content: `Suggest a single emoji icon that represents this conversation: "${title}". Reply with only the emoji, no text.`
					}
				],
				model: modelId,
				temperature: 0.5
			});

			const icon = response.content.trim().match(/[\p{Emoji}]/u)?.[0];
			if (icon) {
				return icon;
			}
		} catch (error) {
			console.error('Failed to generate icon:', error);
		}
		return null;
	}

	private async renameConversation(convId: string) {
		const conv = this.plugin.settings.conversations.find(c => c.id === convId);
		if (!conv) return;

		const newTitle = prompt('Enter new title:', conv.title);
		if (newTitle && newTitle.trim()) {
			conv.title = newTitle.trim();
			await this.plugin.saveSettings();
			this.renderConversationList();
		}
	}

	private async deleteConversation(convId: string) {
		const conv = this.plugin.settings.conversations.find(c => c.id === convId);
		if (!conv) return;

		if (!confirm(`Delete conversation "${conv.title}"?`)) return;

		this.plugin.settings.conversations = this.plugin.settings.conversations.filter(
			c => c.id !== convId
		);

		// If deleting current conversation, switch to another or create new
		if (convId === this.currentConversationId) {
			if (this.plugin.settings.conversations.length > 0) {
				this.loadConversation(this.plugin.settings.conversations[0]);
			} else {
				await this.createNewConversation();
			}
		}

		await this.plugin.saveSettings();
		this.renderConversationList();
	}

	private async refreshModels(showNotice: boolean = false) {
		try {
			// Get all available models from configured providers (uses stored models by default)
			this.availableModels = await ModelManager.getAllAvailableModels(this.plugin.settings.llmConfigs);

			// Update model selector
			this.updateModelOptions();

			if (showNotice) {
				new Notice('Models refreshed');
			}
		} catch (error) {
			console.error('Failed to refresh models:', error);
			if (showNotice) {
				new Notice('Failed to refresh models');
			}
		}
	}

	private updateModelOptions() {
		this.modelSelect.empty();

		// Update model count
		if (this.modelCountEl) {
			this.modelCountEl.setText(`${this.availableModels.length} models`);
		}

		if (this.availableModels.length === 0) {
			const option = this.modelSelect.createEl('option', { text: 'No models available' });
			option.value = '';
			option.disabled = true;
			if (this.modelCountEl) {
				this.modelCountEl.setText('0 models');
			}
			return;
		}

		const defaultModel = this.plugin.settings.defaultModel;

		// Group by provider
		const groupedModels = this.availableModels.reduce((acc, model) => {
			if (!acc[model.provider]) {
				acc[model.provider] = [];
			}
			acc[model.provider].push(model);
			return acc;
		}, {} as Record<string, ModelInfo[]>);

		// Sort providers: put providers with default model first
		const sortedProviders = Object.entries(groupedModels).sort(([providerA, modelsA], [providerB, modelsB]) => {
			const aHasDefault = modelsA.some(m => m.id === defaultModel);
			const bHasDefault = modelsB.some(m => m.id === defaultModel);
			if (aHasDefault && !bHasDefault) return -1;
			if (!aHasDefault && bHasDefault) return 1;
			return providerA.localeCompare(providerB);
		});

		// Add options grouped by provider
		sortedProviders.forEach(([provider, models]) => {
			const optgroup = this.modelSelect.createEl('optgroup');
			optgroup.label = `${provider.toUpperCase()} (${models.length})`;

			// Sort models: default first, then alphabetically
			const sortedModels = [...models].sort((a, b) => {
				if (a.id === defaultModel) return -1;
				if (b.id === defaultModel) return 1;
				return a.name.localeCompare(b.name);
			});

			sortedModels.forEach(model => {
				const isDefault = model.id === defaultModel;
				const option = optgroup.createEl('option', {
					text: isDefault ? `‚≠ê ${model.name} (Default)` : model.name,
				});
				option.value = model.id;
				if (isDefault) {
					option.style.fontWeight = '600';
				}
			});
		});
	}

	private async onModelChange() {
		// Model selection changed, update image button visibility based on vision capability
		await this.updateImageButtonVisibility();
	}

	private async updateImageButtonVisibility() {
		// Check if inputContainer exists before trying to access its elements
		if (!this.inputContainer) return;
		
		const selectedModel = this.modelSelect.value;
		const imageBtn = this.inputContainer.querySelector('.image-btn') as HTMLElement;
		
		if (!imageBtn) return;
		
		// Only show the image button in chat mode AND if the selected model supports vision
		const showImageBtn = this.mode === 'chat' && await this.modelSupportsVision(selectedModel);
		
		imageBtn.style.display = showImageBtn ? 'flex' : 'none';
	}

	private async modelSupportsVision(modelId: string): Promise<boolean> {
		// Find the model to check if it has vision capability
		const allModels = await ModelManager.getAllAvailableModels(this.plugin.settings.llmConfigs);
		const model = allModels.find(m => m.id === modelId);
		
		return model?.capabilities?.includes('vision') || false;
	}

	private async sendMessage(text: string) {
		console.log('[Chat] sendMessage called with text:', text.substring(0, 100) + '...');

		if (this.plugin.settings.llmConfigs.length === 0) {
			console.error('[Chat] No LLM configs found');
			new Notice('Please configure an LLM provider in settings first');
			return;
		}

		// Get selected model
		const selectedModel = this.modelSelect.value;
		console.log('[Chat] Selected model:', selectedModel);

		if (!selectedModel) {
			console.error('[Chat] No model selected');
			new Notice('Please select a model');
			return;
		}

		// Build content for LLM (with full file contents)
		let llmContent = text;

		// Build content for UI display (without file contents, just badges)
		let displayContent = text;

		// Convert referenced files to FileReference objects and read their contents
		const references: FileReference[] = [];

		if (this.referencedFiles.length > 0) {
			llmContent += '\n\n---\n**Referenced Files/Folders:**\n\n';

			for (const item of this.referencedFiles) {
				references.push({
					type: item instanceof TFolder ? 'folder' : 'file',
					path: item.path,
					name: item.name
				});

				if (item instanceof TFile) {
					try {
						const content = await this.app.vault.read(item);
						llmContent += `\n### üìÑ ${item.path}\n`;
						llmContent += '```\n';
						llmContent += content;
						llmContent += '\n```\n';
					} catch (error) {
						llmContent += `\n### üìÑ ${item.path}\n`;
						llmContent += `*Error reading file: ${error.message}*\n`;
					}
				} else if (item instanceof TFolder) {
					// For folders, list the files
					const filesInFolder = this.app.vault.getFiles().filter(f => f.path.startsWith(item.path));
					llmContent += `\n### üìÅ ${item.path}\n`;
					llmContent += `Contains ${filesInFolder.length} file(s):\n`;
					filesInFolder.slice(0, 10).forEach(f => {
						llmContent += `- ${f.path}\n`;
					});
					if (filesInFolder.length > 10) {
						llmContent += `... and ${filesInFolder.length - 10} more files\n`;
					}
				}
			}
		}

		// Add user message (display only shows original text, references shown as badges)
		const userMessage: Message = {
			role: 'user',
			content: displayContent,  // Display content without file contents
			attachments: this.currentAttachments.length > 0 ? [...this.currentAttachments] : undefined,
			references: references.length > 0 ? references : undefined
		};
		this.messages.push(userMessage);
		this.addMessageToUI(userMessage);

		// Find appropriate config for the selected model using fast provider-based matching
		const config = ModelManager.findConfigForModelByProvider(selectedModel, this.plugin.settings.llmConfigs);
		console.log('[Chat] Found config:', config ? config.provider : 'none');

		if (!config) {
			console.error('[Chat] No config found for model:', selectedModel);
			new Notice('No valid provider configuration found for this model');
			return;
		}

		try {
			// Create a temporary config with the selected model
			const modelConfig = {
				...config,
				model: selectedModel,
				temperature: this.temperature,
				maxTokens: this.maxTokens
			};

			console.log('[Chat] Creating provider for:', modelConfig.provider);
			const provider = ProviderFactory.createProvider(modelConfig);
			console.log('[Chat] Provider created successfully');

			// Add system messages
			const systemMessages: any[] = [];

			// Add user-selected system prompt if active
			if (this.plugin.settings.activeSystemPromptId) {
				const activePrompt = this.plugin.settings.systemPrompts.find(
					p => p.id === this.plugin.settings.activeSystemPromptId
				);
				if (activePrompt && activePrompt.enabled) {
					systemMessages.push({
						role: 'system' as const,
						content: activePrompt.content
					});
				}
			}

			// Add agent memory context if using an agent with memory
			if (this.plugin.settings.activeAgentId) {
				const agent = this.plugin.settings.agents.find(a => a.id === this.plugin.settings.activeAgentId);
				if (agent && agent.memoryType !== 'none' && this.currentConversationId) {
					// Get recent conversation summaries
					const recentSummaries = this.memoryManager.getRecentSummaries(agent.id, 3);
					if (recentSummaries.length > 0) {
						const memoryContext = recentSummaries
							.map(s => `[Previous conversation: ${s.summary}]`)
							.join('\n');
						systemMessages.push({
							role: 'system' as const,
							content: `Previous conversation context:\n${memoryContext}`
						});
					}
				}
			}

			// Add system prompt for Agent mode
			if (this.mode === 'agent') {
				const toolsList = this.toolManager.getAllTools().map(tool =>
					`- ${tool.definition.name}: ${tool.definition.description}`
				).join('\n');

				systemMessages.push({
					role: 'system' as const,
					content: `You are an AI agent with access to tools. You can call tools to help answer the user's questions.

Available tools:
${toolsList}

To call a tool, respond with a JSON block in this format:
\`\`\`json
{
  "name": "tool_name",
  "arguments": {
    "arg1": "value1",
    "arg2": "value2"
  }
}
\`\`\`

After calling a tool, you will receive the result and can continue the conversation or call another tool if needed.`
				});
			}

			// Add RAG context if enabled and store sources
			let ragSources: import('../llm/types').RAGSource[] | undefined;
			console.log('[RAG Debug] enableRAG:', this.enableRAG, 'ragConfig.enabled:', this.plugin.settings.ragConfig.enabled);
			if (this.enableRAG && this.plugin.settings.ragConfig.enabled) {
				try {
					console.log('[RAG Debug] Querying RAG with text:', text);
					const searchResults = await this.ragManager.query(text);
					console.log('[RAG Debug] Search results:', searchResults?.length || 0, 'results');
					if (searchResults && searchResults.length > 0) {
						// Store RAG sources for display
						ragSources = searchResults.map(result => ({
							path: result.chunk.metadata.path,
							content: result.chunk.content,
							similarity: result.similarity,
							title: result.chunk.metadata.title
						}));

						// Build context string for LLM
						const ragContext = searchResults
							.map(result => `Document: ${result.chunk.metadata.path}\nContent: ${result.chunk.content}`)
							.join('\n\n');

						console.log('[RAG Debug] RAG context length:', ragContext.length);
						systemMessages.push({
							role: 'system' as const,
							content: `RAG Context (retrieved from your vault):\n\n${ragContext}`
						});
					} else {
						console.log('[RAG Debug] No search results found');
					}
				} catch (error) {
					console.error('[RAG Debug] Error retrieving RAG context:', error);
					new Notice(`RAG error: ${error.message}`);
				}
			} else {
				console.log('[RAG Debug] RAG is disabled');
			}

			// Add web search results if enabled
			let webSearchResults: import('../llm/types').WebSearchResult[] | undefined;
			if (this.enableWebSearch) {
				try {
					new Notice('üîç Searching the web...');
					const results = await this.webSearchService.search(text);
					if (results && results.length > 0) {
						// Store web search results for display
						webSearchResults = results;

						// Build context string for LLM
						const searchContext = this.webSearchService.formatResultsAsContext(results);

						systemMessages.push({
							role: 'system' as const,
							content: searchContext
						});

						new Notice(`‚úÖ Found ${results.length} web results`);
					}
				} catch (error) {
					console.error('Error performing web search:', error);
					new Notice(`Web search error: ${error.message}`);
				}
			}

			// Add think mode instructions if enabled
			if (this.enableThink) {
				systemMessages.push({
					role: 'system' as const,
					content: `Think Mode Enabled: Please show your step-by-step reasoning process. Structure your response as:

1. **Analysis**: Break down the question/problem
2. **Reasoning**: Explain your thought process
3. **Conclusion**: Provide the final answer

Be explicit about each reasoning step and any assumptions you make.`
				});
			}

			// Prepare messages for LLM (convert attachments to text content)
			const llmMessages = this.messages.map((msg, index) => {
				// For the last message (current user message), use llmContent
				const isCurrentMessage = index === this.messages.length - 1;
				let baseContent = isCurrentMessage ? llmContent : msg.content;

				if (!msg.attachments || msg.attachments.length === 0) {
					return { role: msg.role, content: baseContent, model: msg.model };
				}

				// Format message with attachments
				let formattedContent = baseContent;

				// Add file contents
				const fileAttachments = msg.attachments.filter(att => att.type === 'file');
				if (fileAttachments.length > 0) {
					formattedContent += '\n\n---\n**Attached Files:**\n\n';
					fileAttachments.forEach(att => {
						formattedContent += `\n### File: ${att.name}\n`;
						formattedContent += `Path: ${att.path}\n\n`;
						formattedContent += '```\n';
						formattedContent += att.content || '';
						formattedContent += '\n```\n';
					});
				}

				// Add image descriptions (since most text-only models can't process images directly)
				const imageAttachments = msg.attachments.filter(att => att.type === 'image');
				if (imageAttachments.length > 0) {
					formattedContent += '\n\n---\n**Attached Images:**\n\n';
					imageAttachments.forEach(att => {
						formattedContent += `- Image: ${att.name} (Path: ${att.path})\n`;
					});
					formattedContent += '\n*Note: Image content cannot be processed by text-only models. Please describe what you need help with regarding these images.*\n';
				}

				return { role: msg.role, content: formattedContent, model: msg.model };
			});

			// Combine system messages with user messages
			const finalMessages = [...systemMessages, ...llmMessages];
			console.log('[Chat] Final messages count:', finalMessages.length);

			// Create assistant message container with streaming indicator
			const assistantMessageEl = this.addMessageToUI({ role: 'assistant', content: '' });
			const contentEl = assistantMessageEl.querySelector('.message-content') as HTMLElement;

			// Add thinking indicator
			const thinkingIndicator = contentEl.createDiv('thinking-indicator');
			thinkingIndicator.style.display = 'flex';
			thinkingIndicator.style.alignItems = 'center';
			thinkingIndicator.style.gap = '8px';
			thinkingIndicator.style.color = 'var(--text-muted)';
			thinkingIndicator.style.fontStyle = 'italic';
			thinkingIndicator.innerHTML = `
				<div class="typing-dots">
					<span style="animation: typing 1.4s infinite; animation-delay: 0s;">‚óè</span>
					<span style="animation: typing 1.4s infinite; animation-delay: 0.2s;">‚óè</span>
					<span style="animation: typing 1.4s infinite; animation-delay: 0.4s;">‚óè</span>
				</div>
				<span>Thinking...</span>
			`;

			// Set streaming state
			this.isStreaming = true;
			this.stopStreamingRequested = false;
			this.streamingMessageEl = assistantMessageEl;

			// Show stop button, hide send hint
			if (this.stopBtn) this.stopBtn.style.display = 'flex';
			if (this.sendHint) this.sendHint.style.display = 'none';

			let fullContent = '';
			let fullReasoning = ''; // Collect reasoning content
			let tokenCount = 0;
			const startTime = Date.now();

			console.log('[Chat] Starting stream chat...');

			// Create reasoning container (hidden initially)
			let reasoningContainer: HTMLElement | null = null;

			// Stream response with parameters
			try {
				await provider.streamChat(
					{
						messages: finalMessages,
						model: selectedModel,
						temperature: this.temperature,
						maxTokens: this.maxTokens
					},
					(chunk) => {
						// Check if stop was requested
						if (this.stopStreamingRequested) {
							throw new Error('Generation stopped by user');
						}

						if (!chunk.done) {
							// Remove thinking indicator on first chunk
							if (fullContent === '' && fullReasoning === '' && thinkingIndicator.parentElement) {
								thinkingIndicator.remove();
							}

							// Handle reasoning content (DeepSeek R1)
							if (chunk.reasoning) {
								fullReasoning += chunk.reasoning;

								// Create reasoning container if not exists
								if (!reasoningContainer) {
									reasoningContainer = assistantMessageEl.querySelector('.message-body')?.createDiv('reasoning-container') || null;
									if (reasoningContainer) {
										const reasoningHeader = reasoningContainer.createDiv('reasoning-header');
										reasoningHeader.innerHTML = 'üí≠ Reasoning Process';
										reasoningHeader.style.cursor = 'pointer';

										const reasoningContent = reasoningContainer.createDiv('reasoning-content');
										reasoningContent.style.display = 'block'; // Show by default

										// Toggle on click
										reasoningHeader.addEventListener('click', () => {
											if (reasoningContent.style.display === 'none') {
												reasoningContent.style.display = 'block';
												reasoningHeader.innerHTML = 'üí≠ Reasoning Process';
											} else {
												reasoningContent.style.display = 'none';
												reasoningHeader.innerHTML = 'üí≠ Reasoning Process (click to expand)';
											}
										});
									}
								}

								// Update reasoning display
								if (reasoningContainer) {
									const reasoningContent = reasoningContainer.querySelector('.reasoning-content') as HTMLElement;
									if (reasoningContent) {
										reasoningContent.setText(fullReasoning);

										// Add streaming cursor to reasoning
										const cursor = reasoningContent.createEl('span', { cls: 'streaming-cursor' });
										cursor.style.animation = 'blink 1s infinite';
										cursor.innerHTML = '‚ñä';
									}
								}
							}

							// Handle regular content
							if (chunk.content) {
								fullContent += chunk.content;
								tokenCount++;

								// Render markdown during streaming
								try {
									// Clean up excessive newlines before rendering
									const cleanedContent = fullContent.replace(/\n{3,}/g, '\n\n');
									const html = marked.parse(cleanedContent) as string;
									contentEl.innerHTML = html;

									// Add streaming cursor to content
									const cursor = contentEl.createEl('span', { cls: 'streaming-cursor' });
									cursor.style.animation = 'blink 1s infinite';
									cursor.innerHTML = '‚ñä';
								} catch (error) {
									contentEl.setText(fullContent);
								}
							}

							this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
						} else {
							// Remove cursors when done
							const contentCursor = contentEl.querySelector('.streaming-cursor');
							if (contentCursor) contentCursor.remove();

							if (reasoningContainer) {
								const reasoningContent = reasoningContainer.querySelector('.reasoning-content') as HTMLElement;
								const reasoningCursor = reasoningContent?.querySelector('.streaming-cursor');
								if (reasoningCursor) reasoningCursor.remove();
							}
						}
					}
				);
			} finally {
				// Clear streaming state
				this.isStreaming = false;
				this.stopStreamingRequested = false;
				this.streamingMessageEl = null;

				// Hide stop button, show send hint
				if (this.stopBtn) this.stopBtn.style.display = 'none';
				if (this.sendHint) this.sendHint.style.display = 'block';

				// Remove thinking indicator if still present
				if (thinkingIndicator.parentElement) {
					thinkingIndicator.remove();
				}

				// Calculate statistics
				const endTime = Date.now();
				const duration = (endTime - startTime) / 1000; // seconds
				const tokensPerSecond = tokenCount / duration;
				console.log(`[Chat] Streaming complete: ${tokenCount} tokens in ${duration.toFixed(2)}s (${tokensPerSecond.toFixed(1)} tokens/s)`);
			}

			// Estimate token usage
			const completionTokens = this.estimateTokens(fullContent);
			const promptTokens = this.estimateTokens(llmContent);
			const totalTokens = completionTokens + promptTokens;

			// Update messages array with model info, RAG sources, web search results, think mode, and reasoning
			this.messages.push({
				role: 'assistant',
				content: fullContent,
				model: selectedModel,
				ragSources: ragSources,
				webSearchResults: webSearchResults,
				webSearchProvider: webSearchResults ? this.plugin.settings.webSearchConfig.provider : undefined,
				thinkModeEnabled: this.enableThink,
				reasoningContent: fullReasoning || undefined,
				tokenUsage: {
					promptTokens,
					completionTokens,
					totalTokens
				}
			} as Message);

			// Update the token usage summary
			this.updateTokenSummary();

			// Update the assistant message UI with model info
			const nameEl = assistantMessageEl.querySelector('.message-name') as HTMLElement;
			if (nameEl) {
				// Find the provider for this model
				const formattedProvider = config.provider.charAt(0).toUpperCase() + config.provider.slice(1);
				nameEl.setText(`${formattedProvider} / ${selectedModel}`);
				nameEl.style.color = 'var(--text-accent)';
			}

			// In Agent mode, check for tool calls and execute them
			if (this.mode === 'agent') {
				// Initialize agent execution steps for new conversation
				this.agentExecutionSteps = [];

				// Create execution trace container
				const messageBody = assistantMessageEl.querySelector('.message-body') as HTMLElement;
				if (messageBody) {
					const traceContent = this.createAgentExecutionTraceContainer(messageBody);
					await this.processToolCalls(fullContent, traceContent, contentEl);

					// Update trace count after processing
					const countSpan = messageBody.querySelector('.agent-trace-count');
					if (countSpan) {
						countSpan.textContent = `${this.agentExecutionSteps.length} steps`;
					}

					// Extract and show final answer after all processing is complete
					this.displayAgentFinalAnswer(contentEl);
				}
			}

			// Save conversation after successful message
			await this.saveCurrentConversation();

			// Save agent memory if using an agent with memory
			if (this.plugin.settings.activeAgentId && this.currentConversationId) {
				const agent = this.plugin.settings.agents.find(a => a.id === this.plugin.settings.activeAgentId);
				if (agent && agent.memoryType !== 'none') {
					await this.saveAgentMemory(agent, this.messages);
				}
			}

		} catch (error) {
			console.error('[Chat] Error during chat:', error);
			console.error('[Chat] Error stack:', error.stack);
			console.error('[Chat] Provider:', config.provider);
			console.error('[Chat] Model:', selectedModel);
			new Notice(`Chat Error: ${error.message}`);

			// Remove the last user message if there was an error
			this.messages.pop();
			const lastMessage = this.chatContainer.lastElementChild;
			if (lastMessage) {
				this.chatContainer.removeChild(lastMessage);
			}
		}
	}

	private addMessageToUI(message: Message): HTMLElement {
		const messageEl = this.chatContainer.createDiv('chat-message');
		messageEl.addClass(`message-${message.role}`);

		// Message row container (avatar + content)
		const messageRow = messageEl.createDiv('message-row');

		// Avatar
		const avatarEl = messageRow.createDiv('message-avatar');
		if (message.role === 'user') {
			// User avatar
			avatarEl.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>`;
			avatarEl.style.background = 'var(--interactive-accent)';
		} else {
			// Get provider-specific avatar
			const modelId = (message as any).model;
			const config = modelId ? ModelManager.findConfigForModelByProvider(modelId, this.plugin.settings.llmConfigs) : null;
			const providerName = config?.provider || 'unknown';

			avatarEl.innerHTML = this.getProviderAvatar(providerName);
			avatarEl.style.background = this.getProviderColor(providerName);
		}

		// Message body container
		const messageBody = messageRow.createDiv('message-body');

		// Header with name and timestamp
		const header = messageBody.createDiv('message-meta');

		const nameEl = header.createDiv('message-name');
		if (message.role === 'user') {
			nameEl.setText('You');
		} else {
			// Show provider and model name for assistant messages
			const modelId = (message as any).model;
			if (modelId) {
				// Find the provider for this model
				const config = ModelManager.findConfigForModelByProvider(modelId, this.plugin.settings.llmConfigs);
				const providerName = config?.provider || 'Unknown';

				// Format provider name (capitalize first letter)
				const formattedProvider = providerName.charAt(0).toUpperCase() + providerName.slice(1);

				// Show as "Provider / Model"
				nameEl.setText(`${formattedProvider} / ${modelId}`);
				nameEl.style.color = 'var(--text-accent)';
			} else {
				nameEl.setText('Assistant');
			}

			// Add think mode badge if enabled
			if (message.thinkModeEnabled) {
				const thinkBadge = header.createEl('span', { cls: 'think-mode-badge' });
				thinkBadge.innerHTML = 'ü§î Think Mode';
				thinkBadge.title = 'Response generated with step-by-step reasoning';
			}
		}

		// Timestamp (if available)
		const timestamp = header.createDiv('message-timestamp');
		const now = new Date();
		timestamp.setText(now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }));

		// Content
		const contentEl = messageBody.createDiv('message-content');

		// Render markdown for assistant messages
		if (message.role === 'assistant') {
			// Special handling for agent mode messages with execution steps
			if (message.agentExecutionSteps && message.agentExecutionSteps.length > 0) {
				// Extract final answer from content (similar to live execution)
				let finalAnswer = message.content;

				// Remove all tool call blocks
				finalAnswer = finalAnswer.replace(/```json[\s\S]*?```/g, '').trim();

				// Only process ReAct pattern prefixes if this is an agent message (not in chat mode)
				if (this.mode === 'agent') {
					// Remove "Thought:" prefix if present
					finalAnswer = finalAnswer.replace(/^Thought:\s*/i, '').trim();

					// Remove "Observation:" prefix if present
					finalAnswer = finalAnswer.replace(/^Observation:\s*/i, '').trim();

					// Remove "Action:" and anything after it if present
					const actionIndex = finalAnswer.toLowerCase().indexOf('action:');
					if (actionIndex !== -1) {
						finalAnswer = finalAnswer.substring(0, actionIndex).trim();
					}
				}

				if (finalAnswer) {
					const finalAnswerEl = contentEl.createDiv('agent-final-answer');
					finalAnswerEl.innerHTML = `<h4>Final Answer</h4>`;
					try {
						const html = marked.parse(finalAnswer) as string;
						finalAnswerEl.innerHTML += html;
					} catch (error) {
						finalAnswerEl.createDiv().setText(finalAnswer);
					}
				}
			} else {
				// Regular message rendering
				try {
					// Clean up excessive newlines before rendering
					const cleanedContent = message.content.replace(/\n{3,}/g, '\n\n');
					const html = marked.parse(cleanedContent) as string;
					contentEl.innerHTML = html;
				} catch (error) {
					console.error('Markdown rendering error:', error);
					contentEl.setText(message.content);
				}
			}
		} else {
			contentEl.setText(message.content);
		}

		// Display attachments if any
		if (message.attachments && message.attachments.length > 0) {
			const attachmentsEl = messageBody.createDiv('message-attachments');
			message.attachments.forEach(att => {
				const attEl = attachmentsEl.createDiv('attachment-item');
				if (att.type === 'image' && att.content) {
					const img = attEl.createEl('img');
					img.src = att.content;
					img.alt = att.name;
					img.style.maxWidth = '300px';
					img.style.maxHeight = '300px';
					img.style.borderRadius = '8px';
				} else {
					attEl.setText(`üìé ${att.name}`);
				}
			});
		}

		// Display references if any (clickable badges)
		if (message.references && message.references.length > 0) {
			const referencesDisplay = messageBody.createDiv('message-references');
			message.references.forEach(ref => {
				const refBadge = referencesDisplay.createEl('span');
				refBadge.addClass('reference-badge');
				refBadge.innerHTML = `${ref.type === 'folder' ? 'üìÅ' : 'üìÑ'} ${ref.path}`;
				refBadge.style.cursor = 'pointer';
				refBadge.addEventListener('click', async () => {
					if (ref.type === 'file') {
						// Find the file in vault
						const file = this.app.vault.getAbstractFileByPath(ref.path);
						if (file instanceof TFile) {
							await this.app.workspace.getLeaf().openFile(file);
						} else {
							new Notice(`File not found: ${ref.path}`);
						}
					}
				});
			});
		}

		// Display RAG sources if any (for assistant messages)
		if (message.role === 'assistant' && message.ragSources && message.ragSources.length > 0) {
			const ragSourcesContainer = messageBody.createDiv('rag-sources-container');

			// Header
			const header = ragSourcesContainer.createDiv('rag-sources-header');
			header.innerHTML = `üìö Retrieved from ${message.ragSources.length} document${message.ragSources.length > 1 ? 's' : ''}`;

			// Source cards
			const sourcesGrid = ragSourcesContainer.createDiv('rag-sources-grid');
			message.ragSources.forEach((source, index) => {
				const sourceCard = sourcesGrid.createDiv('rag-source-card');

				// Title and similarity
				const sourceHeader = sourceCard.createDiv('rag-source-header');
				const titleEl = sourceHeader.createDiv('rag-source-title');
				titleEl.setText(source.title || source.path.split('/').pop() || source.path);

				const similarityEl = sourceHeader.createDiv('rag-source-similarity');
				const similarityPercent = Math.round(source.similarity * 100);
				similarityEl.setText(`${similarityPercent}%`);
				similarityEl.style.color = similarityPercent > 80 ? 'var(--text-success)' :
											similarityPercent > 60 ? 'var(--text-accent)' :
											'var(--text-muted)';

				// Path
				const pathEl = sourceCard.createDiv('rag-source-path');
				pathEl.setText(source.path);

				// Content preview
				const contentEl = sourceCard.createDiv('rag-source-content');
				const preview = source.content.length > 150
					? source.content.substring(0, 150) + '...'
					: source.content;
				contentEl.setText(preview);

				// Click to open
				sourceCard.style.cursor = 'pointer';
				sourceCard.addEventListener('click', async () => {
					const file = this.app.vault.getAbstractFileByPath(source.path);
					if (file instanceof TFile) {
						await this.app.workspace.getLeaf().openFile(file);
					} else {
						new Notice(`File not found: ${source.path}`);
					}
				});

				// Hover effect
				sourceCard.addEventListener('mouseenter', () => {
					sourceCard.style.borderColor = 'var(--interactive-accent)';
				});
				sourceCard.addEventListener('mouseleave', () => {
					sourceCard.style.borderColor = 'var(--background-modifier-border)';
				});
			});
		}

		// Display web search results if any (for assistant messages)
		if (message.role === 'assistant' && message.webSearchResults && message.webSearchResults.length > 0) {
			const webResultsContainer = messageBody.createDiv('web-results-container');

			// Header
			const header = webResultsContainer.createDiv('web-results-header');
			if (message.webSearchProvider) {
				// Get provider icon from the getProviderAvatar method (which now supports web search providers)
				const providerIcon = this.getProviderAvatar(message.webSearchProvider);
				header.innerHTML = `${providerIcon} ${message.webSearchProvider.charAt(0).toUpperCase() + message.webSearchProvider.slice(1)} - Found ${message.webSearchResults.length} result${message.webSearchResults.length > 1 ? 's' : ''}`;
			} else {
				header.innerHTML = `üîç Found ${message.webSearchResults.length} web result${message.webSearchResults.length > 1 ? 's' : ''}`;
			}

			// Result cards
			const resultsGrid = webResultsContainer.createDiv('web-results-grid');
			message.webSearchResults.forEach((result, index) => {
				const resultCard = resultsGrid.createDiv('web-result-card');

				// Title with rank
				const titleContainer = resultCard.createDiv('web-result-title-container');
				const rankEl = titleContainer.createEl('span', { cls: 'web-result-rank' });
				rankEl.setText(`${index + 1}`);

				const titleEl = titleContainer.createEl('a', { cls: 'web-result-title' });
				titleEl.setText(result.title);
				titleEl.href = result.url;
				titleEl.target = '_blank';
				titleEl.addEventListener('click', (e) => {
					e.stopPropagation();
				});

				// Source URL
				const sourceEl = resultCard.createDiv('web-result-source');
				sourceEl.setText(result.source || new URL(result.url).hostname);

				// Snippet
				const snippetEl = resultCard.createDiv('web-result-snippet');
				snippetEl.setText(result.snippet);

				// Open button
				const openBtn = resultCard.createEl('button', { cls: 'web-result-open-btn' });
				openBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg>`;
				openBtn.title = 'Open in browser';
				openBtn.addEventListener('click', () => {
					window.open(result.url, '_blank');
				});
			});
		}

		// Display reasoning content if any (for DeepSeek R1 and other reasoning models)
		if (message.role === 'assistant' && message.reasoningContent) {
			const reasoningContainer = messageBody.createDiv('reasoning-container');

			const reasoningHeader = reasoningContainer.createDiv('reasoning-header');
			reasoningHeader.innerHTML = 'üí≠ Reasoning Process';
			reasoningHeader.style.cursor = 'pointer';

			const reasoningContent = reasoningContainer.createDiv('reasoning-content');
			reasoningContent.setText(message.reasoningContent);
			reasoningContent.style.display = 'none'; // Collapsed by default for saved messages

			// Toggle on click
			reasoningHeader.addEventListener('click', () => {
				if (reasoningContent.style.display === 'none') {
					reasoningContent.style.display = 'block';
					reasoningHeader.innerHTML = 'üí≠ Reasoning Process (click to collapse)';
				} else {
					reasoningContent.style.display = 'none';
					reasoningHeader.innerHTML = 'üí≠ Reasoning Process (click to expand)';
				}
			});

			// Start with collapsed state text
			reasoningHeader.innerHTML = 'üí≠ Reasoning Process (click to expand)';
		}

		// Display agent execution trace if any (for agent mode)
		if (message.role === 'assistant' && message.agentExecutionSteps && message.agentExecutionSteps.length > 0) {
			const traceContainer = messageBody.createDiv('agent-execution-trace-container');
			traceContainer.style.marginTop = '16px';
			traceContainer.style.borderTop = '1px solid var(--background-modifier-border)';
			traceContainer.style.paddingTop = '16px';

			// Collapsible header
			const header = traceContainer.createDiv('agent-execution-trace-header');
			header.innerHTML = `
				<span class="agent-trace-icon">‚ñ∂</span>
				<span class="agent-trace-title">Execution Trace</span>
				<span class="agent-trace-count">${message.agentExecutionSteps.length} steps</span>
			`;

			// Trace content (collapsed by default)
			const content = traceContainer.createDiv('agent-execution-trace-content');
			content.style.display = 'none';

			// Build timeline
			const timeline = content.createDiv('agent-execution-timeline');
			message.agentExecutionSteps.forEach((step) => {
				const stepEl = timeline.createDiv(`agent-step agent-step-${step.type}`);

				// Step indicator
				const indicator = stepEl.createDiv('agent-step-indicator');
				if (step.type === 'thought') {
					indicator.innerHTML = 'üß†';
				} else if (step.type === 'action') {
					indicator.innerHTML = '‚ö°';
				} else {
					indicator.innerHTML = 'üëÅÔ∏è';
				}

				// Step content
				const contentEl = stepEl.createDiv('agent-step-content');

				// Step header
				const stepHeader = contentEl.createDiv('agent-step-header');
				stepHeader.createSpan({ text: step.type.charAt(0).toUpperCase() + step.type.slice(1), cls: 'agent-step-type' });

				const time = new Date(step.timestamp);
				const timeStr = time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
				stepHeader.createSpan({ text: timeStr, cls: 'agent-step-time' });

				// Step body
				const body = contentEl.createDiv('agent-step-body');
				if (step.type === 'action') {
					// Format action nicely
					const match = step.content.match(/^(\w+)\((.*)\)$/);
					if (match) {
						const toolName = match[1];
						const args = match[2];
						body.innerHTML = `<strong>${toolName}</strong><pre>${args}</pre>`;
					} else {
						body.setText(step.content);
					}
				} else if (step.type === 'observation') {
					// Format observation as code block
					const pre = body.createEl('pre');
					pre.setText(step.content);
				} else {
					body.setText(step.content);
				}
			});

			// Toggle on click
			let isExpanded = false;
			header.addEventListener('click', () => {
				isExpanded = !isExpanded;
				content.style.display = isExpanded ? 'block' : 'none';
				const icon = header.querySelector('.agent-trace-icon');
				if (icon) {
					icon.textContent = isExpanded ? '‚ñº' : '‚ñ∂';
				}
			});
		}

		// Action buttons (shown on hover)
		const actions = messageBody.createDiv('message-actions');

		// Copy button
		const copyBtn = actions.createEl('button');
		copyBtn.addClass('msg-action-btn');
		copyBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>`;
		copyBtn.title = 'Copy message content to clipboard';
		copyBtn.addEventListener('click', async () => {
			await navigator.clipboard.writeText(message.content);
			new Notice('Message copied');
		});

		// Save button
		const saveBtn = actions.createEl('button');
		saveBtn.addClass('msg-action-btn');
		saveBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>`;
		saveBtn.title = 'Save message to a new note';
		saveBtn.addEventListener('click', async () => {
			await this.saveMessageToNewNote(message);
		});

		// Insert button
		const insertBtn = actions.createEl('button');
		insertBtn.addClass('msg-action-btn');
		insertBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>`;
		insertBtn.title = 'Insert message into an existing note';
		insertBtn.addEventListener('click', async () => {
			await this.insertMessageToNote(message);
		});

		// Regenerate button (only for assistant messages)
		if (message.role === 'assistant') {
			const regenerateBtn = actions.createEl('button');
			regenerateBtn.addClass('msg-action-btn');
			regenerateBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="1 4 1 10 7 10"></polyline><polyline points="23 20 23 14 17 14"></polyline><path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path></svg>`;
			regenerateBtn.title = 'Regenerate this response';
			regenerateBtn.addEventListener('click', async () => {
				await this.regenerateMessage(messageEl);
			});
		}

		// Apply to file button (only for assistant messages with code blocks and previous message has references)
		if (message.role === 'assistant') {
			const messageIndex = this.messages.indexOf(message);
			const previousMessage = messageIndex > 0 ? this.messages[messageIndex - 1] : null;

			if (previousMessage && previousMessage.references && previousMessage.references.length > 0) {
				const applyBtn = actions.createEl('button');
				applyBtn.addClass('msg-action-btn');
				applyBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline><circle cx="12" cy="17" r="1"></circle></svg>`;
				applyBtn.title = 'Apply code changes to referenced files';
				applyBtn.addEventListener('click', async () => {
					await this.applyChangesToFile(message, previousMessage.references!);
				});
			}
		}

		// Add metadata indicator (i icon) for assistant messages as a button after all other action buttons
		if (message.role === 'assistant') {
			const metadataContainer = actions.createDiv('message-metadata-container');
			metadataContainer.style.position = 'relative';
			metadataContainer.style.display = 'inline-block';

			const metadataBtn = metadataContainer.createEl('button', { cls: 'msg-action-btn' });
			metadataBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>`;
			metadataBtn.title = 'View token usage and metadata';
			
			const tooltip = metadataContainer.createDiv('msg-metadata-tooltip');
			tooltip.style.position = 'absolute';
			tooltip.style.bottom = '100%';
			tooltip.style.left = '50%';
			tooltip.style.transform = 'translateX(-50%)';
			tooltip.style.background = 'var(--background-primary)';
			tooltip.style.border = '1px solid var(--background-modifier-border)';
			tooltip.style.borderRadius = '4px';
			tooltip.style.padding = '8px';
			tooltip.style.marginBottom = '4px';
			tooltip.style.minWidth = '160px';
			tooltip.style.zIndex = '1000';
			tooltip.style.display = 'none'; // Hidden by default
			tooltip.style.fontSize = '12px';
			tooltip.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';
			
			let usageInfo = [];
			if (message.tokenUsage) {
				if (message.tokenUsage.promptTokens !== undefined) usageInfo.push(`Prompt: ${message.tokenUsage.promptTokens} tokens`);
				if (message.tokenUsage.completionTokens !== undefined) usageInfo.push(`Completion: ${message.tokenUsage.completionTokens} tokens`);
				if (message.tokenUsage.totalTokens !== undefined) usageInfo.push(`Total: ${message.tokenUsage.totalTokens} tokens`);
			} else {
				usageInfo.push('Token usage not available');
			}
			
			tooltip.innerHTML = `
				<div style="font-weight: bold; margin-bottom: 4px;">Token Usage</div>
				<div>${usageInfo.join('<br>')}</div>
				${message.model ? `<div style="margin-top: 4px;">Model: ${message.model}</div>` : ''}
			`;

			// Show tooltip on hover
			metadataBtn.addEventListener('mouseenter', () => {
				tooltip.style.display = 'block';
			});
			
			metadataBtn.addEventListener('mouseleave', () => {
				tooltip.style.display = 'none';
			});
		}

		this.chatContainer.scrollTop = this.chatContainer.scrollHeight;

		return messageEl;
	}

	private styleActionButton(btn: HTMLButtonElement) {
		btn.style.padding = '2px 6px';
		btn.style.border = 'none';
		btn.style.background = 'transparent';
		btn.style.cursor = 'pointer';
		btn.style.borderRadius = '4px';
		btn.style.opacity = '0.6';
		btn.style.fontSize = '14px';
		btn.addEventListener('mouseenter', () => {
			btn.style.opacity = '1';
			btn.style.background = 'var(--background-modifier-hover)';
		});
		btn.addEventListener('mouseleave', () => {
			btn.style.opacity = '0.6';
			btn.style.background = 'transparent';
		});
	}

	private showReferenceMenu() {
		new SearchableReferenceModal(this.app, (selectedItems: (TFile | TFolder)[]) => {
			selectedItems.forEach(item => {
				if (!this.referencedFiles.some(ref => ref.path === item.path)) {
					this.referencedFiles.push(item);
				}
			});
			this.updateReferenceDisplay();
			if (selectedItems.length > 0) {
				new Notice(`Added ${selectedItems.length} reference(s)`);
			}
		}).open();
	}

	private updateReferenceDisplay() {
		if (!this.referenceContainer) return;

		const referenceList = this.referenceContainer.querySelector('.reference-list') as HTMLElement;
		if (!referenceList) return;

		referenceList.empty();

		if (this.referencedFiles.length === 0) {
			this.referenceContainer.style.display = 'none';
			return;
		}

		this.referenceContainer.style.display = 'block';

		this.referencedFiles.forEach((item, index) => {
			const refItem = referenceList.createDiv('reference-item');
			refItem.innerHTML = `<span class="reference-icon">${item instanceof TFolder ? 'üìÅ' : 'üìÑ'}</span> <span class="reference-path">${item.path}</span>`;

			// Make it clickable to open the file/folder
			refItem.style.cursor = 'pointer';
			refItem.addEventListener('click', () => {
				if (item instanceof TFile) {
					this.app.workspace.getLeaf().openFile(item);
				}
			});

			// Remove button
			const removeBtn = refItem.createEl('button', { text: '√ó' });
			removeBtn.addClass('reference-remove-btn');
			removeBtn.addEventListener('click', (e) => {
				e.stopPropagation();
				this.referencedFiles.splice(index, 1);
				this.updateReferenceDisplay();
			});
		});
	}

	private async regenerateMessage(messageEl: HTMLElement) {
		// Find the assistant message index
		const messageIndex = Array.from(this.chatContainer.children).indexOf(messageEl);
		if (messageIndex < 0) return;

		// Find the corresponding message in the array
		const messages = this.messages.filter(m => m.role !== 'system');
		const assistantMsgIndex = messages.findIndex((m, idx) => {
			// Count how many messages have been rendered before this one
			const renderedIndex = messages.slice(0, idx + 1).length - 1;
			return renderedIndex === messageIndex && m.role === 'assistant';
		});

		if (assistantMsgIndex < 0) {
			new Notice('Cannot find message to regenerate');
			return;
		}

		// Get the user message before this assistant message
		let userMessageIndex = assistantMsgIndex - 1;
		while (userMessageIndex >= 0 && messages[userMessageIndex].role !== 'user') {
			userMessageIndex--;
		}

		if (userMessageIndex < 0) {
			new Notice('Cannot find user message to regenerate from');
			return;
		}

		const userMessage = messages[userMessageIndex];

		// Remove the assistant message from UI and array
		messageEl.remove();
		this.messages.splice(this.messages.indexOf(messages[assistantMsgIndex]), 1);

		// Resend the user message
		new Notice('Regenerating response...');
		await this.sendMessage(userMessage.content);
	}

	private async saveMessageToNewNote(message: Message) {
		// Use modal for input
		const defaultName = `Chat Message ${new Date().toLocaleDateString()}`;

		new TextInputModal(
			this.app,
			'Create New Note',
			'Enter note name',
			defaultName,
			async (noteName) => {
				if (!noteName || !noteName.trim()) return;

				try {
					// Create note path (sanitize name)
					const fileName = noteName.replace(/[\\/:*?"<>|]/g, '-') + '.md';

					// Format content with metadata
					let content = `# ${noteName}\n\n`;
					content += `Created from AI chat on ${new Date().toLocaleString()}\n\n`;
					content += `---\n\n`;

					// Add role header
					if (message.role === 'user') {
						content += `## üí¨ User Message\n\n`;
					} else {
						const modelName = (message as any).model || 'Assistant';
						content += `## ü§ñ ${modelName}\n\n`;
					}

					content += message.content + '\n';

					// Create the file
					await this.app.vault.create(fileName, content);
					new Notice(`Note created: ${fileName}`);

					// Open the new note
					const file = this.app.vault.getAbstractFileByPath(fileName);
					if (file instanceof TFile) {
						await this.app.workspace.getLeaf(false).openFile(file);
					}
				} catch (error) {
					console.error('Error creating note:', error);
					new Notice('Failed to create note: ' + error.message);
				}
			}
		).open();
	}

	private async insertMessageToNote(message: Message) {
		new SingleFileSelectionModal(this.app, async (selectedFile) => {
			if (selectedFile) {
				// Insert into selected file
				try {
					// Read current content
					let content = await this.app.vault.read(selectedFile);

					// Add message content
					content += `\n\n---\n\n`;

					// Add role header
					if (message.role === 'user') {
						content += `## üí¨ User Message (${new Date().toLocaleString()})\n\n`;
					} else {
						const modelName = (message as any).model || 'Assistant';
						content += `## ü§ñ ${modelName} (${new Date().toLocaleString()})\n\n`;
					}

					content += message.content + '\n';

					// Write back
					await this.app.vault.modify(selectedFile, content);
					new Notice(`Message inserted to: ${selectedFile.path}`);

					// Open the file
					await this.app.workspace.getLeaf(false).openFile(selectedFile);
				} catch (error) {
					console.error('Error inserting to note:', error);
					new Notice('Failed to insert message: ' + error.message);
				}
			} else {
				// Create new note option was selected
				this.saveMessageToNewNote(message);
			}
		}).open();
	}

	private async applyChangesToFile(message: Message, references: FileReference[]) {
		// Extract code blocks from assistant message
		const codeBlockRegex = /```(?:\w+)?\n([\s\S]*?)```/g;
		const matches = [...message.content.matchAll(codeBlockRegex)];

		if (matches.length === 0) {
			new Notice('No code blocks found in message to apply');
			return;
		}

		// If multiple files referenced, let user choose
		if (references.length > 1) {
			const menu = new Menu();
			references.forEach(ref => {
				if (ref.type === 'file') {
					menu.addItem(item => {
						item.setTitle(ref.path)
							.setIcon('document')
							.onClick(async () => {
								await this.applyToSpecificFile(ref.path, matches, message.content);
							});
					});
				}
			});
			menu.showAtMouseEvent(event as MouseEvent);
		} else if (references.length === 1 && references[0].type === 'file') {
			// Single file, apply directly
			await this.applyToSpecificFile(references[0].path, matches, message.content);
		} else {
			new Notice('No file reference found to apply changes');
		}
	}

	private async applyToSpecificFile(filePath: string, codeMatches: RegExpMatchArray[], fullContent: string) {
		const file = this.app.vault.getAbstractFileByPath(filePath);
		if (!(file instanceof TFile)) {
			new Notice(`File not found: ${filePath}`);
			return;
		}

		try {
			// If there's only one code block, use it directly
			if (codeMatches.length === 1) {
				const newContent = codeMatches[0][1].trim();
				await this.app.vault.modify(file, newContent);
				new Notice(`‚úÖ Applied changes to ${filePath}`);
				return;
			}

			// Multiple code blocks - let user choose
			const menu = new Menu();
			codeMatches.forEach((match, index) => {
				const preview = match[1].trim().substring(0, 50) + '...';
				menu.addItem(item => {
					item.setTitle(`Code block ${index + 1}: ${preview}`)
						.setIcon('code')
						.onClick(async () => {
							const newContent = match[1].trim();
							await this.app.vault.modify(file, newContent);
							new Notice(`‚úÖ Applied code block ${index + 1} to ${filePath}`);
						});
				});
			});

			// Add option to replace entire file with all blocks
			menu.addSeparator();
			menu.addItem(item => {
				item.setTitle('Use entire response content')
					.setIcon('file-text')
					.onClick(async () => {
						await this.app.vault.modify(file, fullContent);
						new Notice(`‚úÖ Applied entire response to ${filePath}`);
					});
			});

			menu.showAtMouseEvent(event as MouseEvent);
		} catch (error) {
			console.error('Error applying changes:', error);
			new Notice(`‚ùå Failed to apply changes: ${error.message}`);
		}
	}

	private createCheckbox(container: HTMLElement, label: string, checked: boolean, onChange: (checked: boolean) => void): HTMLInputElement {
		const checkboxContainer = container.createDiv('checkbox-container');
		const checkbox = checkboxContainer.createEl('input', { type: 'checkbox' });
		checkbox.checked = checked;
		checkbox.addEventListener('change', () => onChange(checkbox.checked));

		const labelEl = checkboxContainer.createEl('label');
		labelEl.setText(label);
		labelEl.style.marginLeft = '4px';
		labelEl.style.cursor = 'pointer';
		labelEl.addEventListener('click', () => {
			checkbox.checked = !checkbox.checked;
			onChange(checkbox.checked);
		});

		return checkbox;
	}

	private createToggleButton(
		container: HTMLElement,
		options: { icon: string; label: string; active: boolean; disabled?: boolean; disabledMessage?: string; onChange: (active: boolean) => void; statusText?: string }
	): HTMLElement {
		const toggleBtn = container.createEl('button');
		toggleBtn.addClass('toggle-btn');
		if (options.active) {
			toggleBtn.addClass('active');
		}
		if (options.disabled) {
			toggleBtn.addClass('disabled');
			toggleBtn.disabled = true;
			toggleBtn.style.opacity = '0.5';
			toggleBtn.style.cursor = 'not-allowed';
			if (options.disabledMessage) {
				toggleBtn.title = options.disabledMessage;
			}
		}

		const iconSpan = toggleBtn.createEl('span', { cls: 'toggle-icon' });
		iconSpan.setText(options.icon);

		const labelSpan = toggleBtn.createEl('span', { cls: 'toggle-label' });
		labelSpan.setText(options.label);

		// Add status text if provided
		if (options.statusText) {
			const statusSpan = toggleBtn.createEl('span', { cls: 'toggle-status' });
			statusSpan.setText(` (${options.statusText})`);
			statusSpan.style.opacity = '0.7';
			statusSpan.style.fontSize = '0.8em';
			statusSpan.style.marginLeft = '4px';
		}

		toggleBtn.addEventListener('click', (e) => {
			e.preventDefault();
			if (options.disabled) {
				if (options.disabledMessage) {
					new Notice(options.disabledMessage);
				}
				return;
			}
			const newActive = !toggleBtn.hasClass('active');
			if (newActive) {
				toggleBtn.addClass('active');
			} else {
				toggleBtn.removeClass('active');
			}
			options.onChange(newActive);
		});

		return toggleBtn;
	}
	
	private async updateRagStatus(ragToggle: HTMLElement) {
		if (!ragToggle) return;

		try {
			const stats = await this.ragManager.getDetailedStats();
			const statusText = stats.chunkCount > 0
				? `${stats.chunkCount} chunks, ${stats.fileCount} files`
				: 'No index';

			// Remove any existing status element
			const existingStatus = ragToggle.querySelector('.toggle-status');
			if (existingStatus) {
				existingStatus.remove();
			}

			// Add new status element
			const statusSpan = ragToggle.createEl('span', { cls: 'toggle-status' });
			statusSpan.setText(` (${statusText})`);
			statusSpan.style.opacity = '0.7';
			statusSpan.style.fontSize = '0.8em';
			statusSpan.style.marginLeft = '4px';
			statusSpan.style.whiteSpace = 'nowrap';

			// Create detailed tooltip
			let tooltipText = `RAG Index Status:\n\n`;
			tooltipText += `üìä Total Chunks: ${stats.chunkCount}\n`;
			tooltipText += `üìÅ Files Indexed: ${stats.fileCount}\n`;
			tooltipText += `üíæ Total Size: ${(stats.totalSize / 1024).toFixed(1)} KB\n`;

			if (stats.indexedFiles && stats.indexedFiles.length > 0) {
				tooltipText += `\nüìÑ Indexed Files:\n`;
				// Show first 10 files
				const filesToShow = stats.indexedFiles.slice(0, 10);
				filesToShow.forEach(file => {
					const fileName = file.split('/').pop() || file;
					tooltipText += `  ‚Ä¢ ${fileName}\n`;
				});

				if (stats.indexedFiles.length > 10) {
					tooltipText += `  ... and ${stats.indexedFiles.length - 10} more\n`;
				}
			} else {
				tooltipText += `\n‚ö†Ô∏è No files indexed yet.\n`;
				tooltipText += `Go to Settings ‚Üí RAG to build the index.`;
			}

			statusSpan.title = tooltipText;

			// Add click handler to show stats modal
			statusSpan.style.cursor = 'help';
			statusSpan.addEventListener('click', (e) => {
				e.stopPropagation();
				this.showRagStatsModal(stats);
			});
		} catch (error) {
			console.error('Error updating RAG status:', error);
		}
	}

	private showRagStatsModal(stats: { chunkCount: number, fileCount: number, totalSize: number, indexedFiles: string[] }) {
		const modal = new Modal(this.app);
		modal.titleEl.setText('üìö RAG Index Statistics');

		const content = modal.contentEl;
		content.empty();
		content.addClass('rag-stats-modal');

		// Summary stats
		const summaryDiv = content.createDiv('rag-stats-summary');
		summaryDiv.innerHTML = `
			<div class="stat-row">
				<span class="stat-label">üìä Total Chunks:</span>
				<span class="stat-value">${stats.chunkCount}</span>
			</div>
			<div class="stat-row">
				<span class="stat-label">üìÅ Files Indexed:</span>
				<span class="stat-value">${stats.fileCount}</span>
			</div>
			<div class="stat-row">
				<span class="stat-label">üíæ Total Size:</span>
				<span class="stat-value">${(stats.totalSize / 1024).toFixed(1)} KB</span>
			</div>
			<div class="stat-row">
				<span class="stat-label">üìà Avg Chunks/File:</span>
				<span class="stat-value">${stats.fileCount > 0 ? (stats.chunkCount / stats.fileCount).toFixed(1) : '0'}</span>
			</div>
		`;

		// File list
		if (stats.indexedFiles && stats.indexedFiles.length > 0) {
			const filesDiv = content.createDiv('rag-stats-files');
			filesDiv.createEl('h4', { text: 'üìÑ Indexed Files' });

			const fileList = filesDiv.createDiv('rag-file-list');
			stats.indexedFiles.forEach(filePath => {
				const fileItem = fileList.createDiv('rag-file-item');
				const fileName = filePath.split('/').pop() || filePath;
				const fileLink = fileItem.createEl('a', {
					text: fileName,
					cls: 'rag-file-link'
				});
				fileLink.title = filePath;
				fileLink.addEventListener('click', async (e) => {
					e.preventDefault();
					const file = this.app.vault.getAbstractFileByPath(filePath);
					if (file instanceof TFile) {
						await this.app.workspace.getLeaf().openFile(file);
						modal.close();
					} else {
						new Notice(`File not found: ${filePath}`);
					}
				});

				const filePathSpan = fileItem.createEl('span', {
					text: filePath,
					cls: 'rag-file-path'
				});
			});
		} else {
			const noFiles = content.createDiv('rag-no-files');
			noFiles.innerHTML = `
				<p>‚ö†Ô∏è No files have been indexed yet.</p>
				<p>To build the RAG index:</p>
				<ol>
					<li>Go to Settings ‚Üí RAG</li>
					<li>Enable RAG</li>
					<li>Click "Index Vault"</li>
				</ol>
			`;
		}

		// Close button
		const btnContainer = content.createDiv('modal-button-container');
		const closeBtn = btnContainer.createEl('button', { text: 'Close', cls: 'mod-cta' });
		closeBtn.addEventListener('click', () => modal.close());

		modal.open();
	}

	private getProviderAvatar(provider: string): string {
		const icons: Record<string, string> = {
			'openai': `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M22.282 9.821a5.985 5.985 0 0 0-.516-4.91 6.046 6.046 0 0 0-6.51-2.9A6.065 6.065 0 0 0 4.981 4.18a5.985 5.985 0 0 0-3.998 2.9 6.046 6.046 0 0 0 .743 7.097 5.98 5.98 0 0 0 .51 4.911 6.051 6.051 0 0 0 6.515 2.9A5.985 5.985 0 0 0 13.26 24a6.056 6.056 0 0 0 5.772-4.206 5.99 5.99 0 0 0 3.997-2.9 6.056 6.056 0 0 0-.747-7.073zM13.26 22.43a4.476 4.476 0 0 1-2.876-1.04l.141-.081 4.779-2.758a.795.795 0 0 0 .392-.681v-6.737l2.02 1.168a.071.071 0 0 1 .038.052v5.583a4.504 4.504 0 0 1-4.494 4.494zM3.6 18.304a4.47 4.47 0 0 1-.535-3.014l.142.085 4.783 2.759a.771.771 0 0 0 .78 0l5.843-3.369v2.332a.08.08 0 0 1-.033.062L9.74 19.95a4.5 4.5 0 0 1-6.14-1.646zM2.34 7.896a4.485 4.485 0 0 1 2.366-1.973V11.6a.766.766 0 0 0 .388.676l5.815 3.355-2.02 1.168a.076.076 0 0 1-.071 0l-4.83-2.786A4.504 4.504 0 0 1 2.34 7.872zm16.597 3.855l-5.833-3.387L15.119 7.2a.076.076 0 0 1 .071 0l4.83 2.791a4.494 4.494 0 0 1-.676 8.105v-5.678a.79.79 0 0 0-.407-.667zm2.01-3.023l-.141-.085-4.774-2.782a.776.776 0 0 0-.785 0L9.409 9.23V6.897a.066.066 0 0 1 .028-.061l4.83-2.787a4.5 4.5 0 0 1 6.68 4.66zm-12.64 4.135l-2.02-1.164a.08.08 0 0 1-.038-.057V6.075a4.5 4.5 0 0 1 7.375-3.453l-.142.08L8.704 5.46a.795.795 0 0 0-.393.681zm1.097-2.365l2.602-1.5 2.607 1.5v2.999l-2.597 1.5-2.607-1.5z"/></svg>`,
			'anthropic': `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M14.5 3h-3L4 21h3.5l1.5-3.5h6.5L17 21h3.5L14.5 3zm-1.5 11l2-5 2 5h-4z"/></svg>`,
			'google': `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/><path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>`,
			'deepseek': `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L2 7v10c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V7l-10-5zm0 10c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"/></svg>`,
			'ollama': `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>`,
			'openrouter': `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L1 21h22L12 2zm0 5l7 12H5l7-12z"/></svg>`,
			'sap-ai-core': `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M3 3v18h18V3H3zm8 14H7v-2h4v2zm0-4H7v-2h4v2zm0-4H7V7h4v2zm6 8h-4v-2h4v2zm0-4h-4v-2h4v2zm0-4h-4V7h4v2z"/></svg>`,
			// Additional popular provider logos
			'groq': `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 14.5v-9l6 4.5-6 4.5z"/></svg>`,
			'mistral': `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L2 7v10c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V7l-10-5zm0 10c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"/></svg>`,
			'togetherai': `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><circle cx="12" cy="12" r="10"/><circle cx="9" cy="12" r="2"/><circle cx="15" cy="12" r="2"/></svg>`,
			'perplexity': `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm3.5 10H12v3.5c0 .28-.22.5-.5.5s-.5-.22-.5-.5V12H7.5c-.28 0-.5-.22-.5-.5s.22-.5.5-.5h3.5V7.5c0-.28.22-.5.5-.5s.5.22.5.5V11h3.5c.28 0 .5.22.5.5s-.22.5-.5.5z"/></svg>`,
			'cohere': `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/><circle cx="12" cy="12" r="5"/></svg>`,
			'huggingface': `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8 0-1.85.63-3.55 1.69-4.9L16.9 18.31C15.55 19.37 13.85 20 12 20zm6.31-3.1L7.1 5.69C8.45 4.63 10.15 4 12 4c4.41 0 8 3.59 8 8 0 1.85-.63 3.55-1.69 4.9z"/></svg>`,
			'azure': `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M21 13H13v8l8-8zm-10 4H3l8-8v8zm-4-7h8V2L7 10zm10-8v8l8-8h-8z"/></svg>`,
			'bedrock': `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2l3.09 6.26L22 9.24l-5 4.87 1.18 6.88L12 17.77l-6.18 3.22L7 14.11 2 9.24l6.91-1.02L12 2z"/></svg>`,
			'vertext': `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8 0-1.85.63-3.55 1.69-4.9L16.9 18.31C15.55 19.37 13.85 20 12 20zm6.31-3.1L7.1 5.69C8.45 4.63 10.15 4 12 4c4.41 0 8 3.59 8 8 0 1.85-.63 3.55-1.69 4.9z"/></svg>`,
			'fireworks': `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></svg>`,
			'lepton': `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>`,
			'xai': `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8 0-1.85.63-3.55 1.69-4.9L16.9 18.31C15.55 19.37 13.85 20 12 20zm6.31-3.1L7.1 5.69C8.45 4.63 10.15 4 12 4c4.41 0 8 3.59 8 8 0 1.85-.63 3.55-1.69 4.9z"/></svg>`,
			// Web search provider icons
			'duckduckgo': `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><circle cx="12" cy="12" r="10" fill="#DE5833"/><path d="M12 6v6l4 2" stroke="white" stroke-width="1.5" stroke-linecap="round"/></svg>`,
			'bing': `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M3 3h18v18H3V3Z" fill="#008375"/><path d="M8 8h8v8H8v-8Z" fill="white"/></svg>`,
			'serpapi': `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><rect x="3" y="3" width="6" height="6" fill="#34A853"/><rect x="10.5" y="3" width="6" height="6" fill="#4285F4"/><rect x="18" y="3" width="6" height="6" fill="#FBBC05"/><rect x="3" y="10.5" width="6" height="6" fill="#EA4335"/></svg>`,
			'tavily': `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L4 5V19L12 22L20 19V5L12 2Z" fill="#4F46E5"/><path d="M12 7L16 9V15L12 17L8 15V9L12 7Z" fill="white"/></svg>`,
			'searxng': `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><circle cx="12" cy="12" r="10" fill="#3D6EE0"/><circle cx="12" cy="12" r="4" fill="#F6AB2F"/></svg>`,
			'brave': `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L2 7L12 22L22 7L12 2Z" stroke="#FB541D" stroke-width="2" fill="none"/><path d="M8 9L12 17L16 9" stroke="#FB541D" stroke-width="2"/></svg>`,
			'yahoo': `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L2 7V17L12 22L22 17V7L12 2Z" fill="#720E9E"/><circle cx="12" cy="12" r="3" fill="#FFC300"/></svg>`,
			'yandex': `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L2 7V17L12 22L22 17V7L12 2Z" fill="#FF0000"/><rect x="10" y="8" width="4" height="8" fill="white"/></svg>`,
			'qwant': `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><circle cx="12" cy="12" r="10" fill="#1E8FFF"/><circle cx="12" cy="12" r="5" fill="#FFD600"/></svg>`,
			'mojeek': `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><circle cx="12" cy="12" r="10" fill="#00A651"/><path d="M8 8h8v8H8z" fill="#FFFFFF"/></svg>`
		};

		return icons[provider.toLowerCase()] || `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>`;
	}

	private getProviderColor(provider: string): string {
		const colors: Record<string, string> = {
			'openai': '#10A37F',
			'anthropic': '#D4A574',
			'google': '#4285F4',
			'deepseek': '#1E40AF',
			'ollama': '#9333EA',
			'openrouter': '#F59E0B',
			'sap-ai-core': '#0070F2'
		};

		return colors[provider.toLowerCase()] || 'var(--background-modifier-border)';
	}

	/**
	 * Estimate token count from text content
	 * Uses a simple approximation: ~1 token = 4 characters for English text
	 * This is a rough estimate; actual tokenizers may differ
	 */
	private estimateTokens(text: string): number {
		if (!text || typeof text !== 'string') return 0;
		
		// Simple estimation: 1 token ‚âà 4 characters for English text
		// More accurate would be to use a tokenizer, but this is a good approximation
		return Math.ceil(text.length / 4);
	}

	/**
	 * Calculate and update the total token usage summary for the conversation
	 */
	private updateTokenSummary() {
		if (!this.tokenSummaryEl) return;

		let totalPromptTokens = 0;
		let totalCompletionTokens = 0;
		let totalTokens = 0;

		for (const message of this.messages) {
			if (message.role === 'assistant' && message.tokenUsage) {
				totalPromptTokens += message.tokenUsage.promptTokens || 0;
				totalCompletionTokens += message.tokenUsage.completionTokens || 0;
				totalTokens += message.tokenUsage.totalTokens || 0;
			}
		}

		// Format the display text
		if (totalTokens > 0) {
			this.tokenSummaryEl.setText(`Tokens: ${totalTokens} (${totalPromptTokens} input + ${totalCompletionTokens} output)`);
		} else {
			this.tokenSummaryEl.setText('Tokens: 0');
		}
	}

	private async updateOptionsDisplay() {
		// Check if inputContainer exists before trying to access its elements
		if (!this.inputContainer) return;
		
		const chatOptions = this.inputContainer.querySelector('.chat-mode-options') as HTMLElement;
		const agentOptions = this.inputContainer.querySelector('.agent-mode-options') as HTMLElement;

		if (this.mode === 'chat') {
			if (chatOptions) chatOptions.style.display = 'flex';
			if (agentOptions) agentOptions.style.display = 'none';
		} else {
			if (chatOptions) chatOptions.style.display = 'none';
			if (agentOptions) agentOptions.style.display = 'block';
		}
		
		// Update image button visibility based on mode and model vision capability
		this.updateImageButtonVisibility(); // Fire and forget the async update
	}

	private async applyAgentConfig(agentId: string) {
		const agent = this.plugin.settings.agents.find(a => a.id === agentId);
		if (!agent) return;

		// Apply agent's LLM configuration
		this.temperature = agent.temperature;
		this.maxTokens = agent.maxTokens;

		// Update UI elements if they exist
		if (this.temperatureSlider) {
			this.temperatureSlider.value = String(agent.temperature);
		}
		if (this.maxTokensInput) {
			this.maxTokensInput.value = String(agent.maxTokens);
		}

		// Select agent's model if available
		const modelOption = Array.from(this.modelSelect.options).find(
			opt => opt.value === agent.modelId
		);
		if (modelOption) {
			this.modelSelect.value = agent.modelId;
		}

		// Apply agent's system prompt
		if (agent.systemPromptId) {
			this.plugin.settings.activeSystemPromptId = agent.systemPromptId;
		}

		// Apply agent's feature flags
		this.enableRAG = agent.ragEnabled;
		this.enableWebSearch = agent.webSearchEnabled;
		this.enableThink = agent.thinkMode;

		// Update tool manager with agent's enabled tools
		const toolConfigs = agent.enabledBuiltInTools.map(toolType => ({
			type: toolType as any,
			enabled: true
		}));
		this.toolManager.setToolConfigs(toolConfigs);

		// Update RAG manager with agent configuration
		try {
			await this.ragManager.updateConfig(this.plugin.settings.ragConfig);
			await this.ragManager.initialize();
			
			// Update RAG status
			if (this.ragToggleBtn) {
				await this.updateRagStatus(this.ragToggleBtn);
			}
		} catch (error) {
			console.error('Error updating RAG with agent config:', error);
		}

		new Notice(`Applied configuration for agent: ${agent.icon || 'ü§ñ'} ${agent.name}`);
	}

	private async saveAgentMemory(agent: Agent, messages: Message[]) {
		if (!this.currentConversationId) return;

		const summaryInterval = agent.memoryConfig?.summaryInterval || 10;

		// Check if we should create a summary
		if (messages.length >= summaryInterval && messages.length % summaryInterval === 0) {
			// Find appropriate config for summary generation
			const config = this.plugin.settings.llmConfigs.find(c => c.provider === 'openai');
			if (!config) return;

			const provider = ProviderFactory.createProvider(config);

			// Generate summary of recent messages
			const recentMessages = messages.slice(-summaryInterval);
			const summary = await this.memoryManager.generateSummary(
				recentMessages,
				provider,
				agent.modelId
			);

			// Save summary
			this.memoryManager.addConversationSummary(
				agent.id,
				this.currentConversationId,
				summary,
				recentMessages.length
			);

			// Update plugin settings with new memories
			this.plugin.settings.agentMemories = this.memoryManager.exportMemories();
			await this.plugin.saveSettings();
		}
	}

	private async executeWorkflow(workflowPath: string) {
		// Load workflow from file
		const { WorkflowFileManager } = await import('../workflows/workflow-file-manager');
		const workflowManager = new WorkflowFileManager(this.app);
		const workflowFile = this.app.vault.getAbstractFileByPath(workflowPath);

		if (!workflowFile || !(workflowFile instanceof TFile)) {
			new Notice('Workflow file not found');
			return;
		}

		const workflow = await workflowManager.loadWorkflowFromFile(workflowFile);
		if (!workflow) {
			new Notice('Failed to load workflow');
			return;
		}

		new Notice(`Executing workflow: ${workflow.name}`);

		// Add workflow execution message
		const workflowMsgEl = this.chatContainer.createDiv('chat-message');
		workflowMsgEl.addClass('message-workflow');
		workflowMsgEl.innerHTML = `
			<div class="workflow-execution">
				<div class="workflow-header">
					<span class="workflow-icon">${workflow.icon || '‚öôÔ∏è'}</span>
					<span class="workflow-name">Workflow: ${workflow.name}</span>
				</div>
				<div class="workflow-status">Initializing...</div>
				<div class="workflow-log"></div>
			</div>
		`;

		const statusEl = workflowMsgEl.querySelector('.workflow-status') as HTMLElement;
		const logEl = workflowMsgEl.querySelector('.workflow-log') as HTMLElement;

		try {
			// Import enhanced workflow executor
			const { EnhancedWorkflowExecutor } = await import('../workflows/enhanced-workflow-executor');
			const { INodeExecutionData } = await import('../workflows/data-model');

			// Create executor with enhanced capabilities
			const executor = new EnhancedWorkflowExecutor(
				{
					...workflow,
					id: workflow.id,
					name: workflow.name,
					version: 1,
					nodes: workflow.nodes.map(node => ({
						...node,
						parameters: node.config || {}
					})),
					connections: {},
					settings: {},
					active: true,
					createdAt: new Date(workflow.createdAt || Date.now()),
					updatedAt: new Date(workflow.updatedAt || Date.now()),
					description: workflow.description
				},
				this.app
			);

			// Set up LLM provider (this would need to be handled differently in the enhanced executor)
			const selectedModel = this.modelSelect.value || 'gpt-4o';
			const config = await import('../llm/model-manager').then(({ ModelManager }) =>
				ModelManager.findConfigForModelByProvider(selectedModel, this.plugin.settings.llmConfigs)
			);

			// Get input from last user message or prompt
			const lastUserMessage = this.messages.filter(m => m.role === 'user').pop();
			const initialInput = lastUserMessage?.content || 'Start workflow';

			statusEl.setText('Running...');

			// Prepare initial data for execution
			const initialData = [{
				json: { 
					input: initialInput,
					userMessage: initialInput,
					workflowId: workflow.id,
					timestamp: Date.now()
				},
				itemIndex: 0
			}];

			// Execute workflow with enhanced executor
			const execution = await executor.execute(initialData);

			// Display results
			statusEl.setText(`Status: ${execution.status}`);
			statusEl.style.color = execution.status === 'completed' ? 'var(--text-success)' : 'var(--text-error)';

			// Display execution log
			logEl.empty();
			const logTitle = logEl.createEl('h4', { text: 'Execution Log:' });
			logTitle.style.margin = '8px 0 4px 0';

			for (const entry of execution.executionLog) {
				const entryDiv = logEl.createDiv('log-entry');
				entryDiv.style.cssText = 'font-size: 11px; padding: 4px 0; border-bottom: 1px solid var(--background-modifier-border);';

				const timestamp = new Date(entry.timestamp).toLocaleTimeString();
				const actionText = `[${timestamp}] ${entry.nodeName}: ${entry.action}`;

				entryDiv.createEl('div', { text: actionText, cls: 'log-action' });

				if (entry.output) {
					const outputDiv = entryDiv.createEl('div', { cls: 'log-output' });
					outputDiv.style.cssText = 'color: var(--text-muted); margin-left: 16px; font-family: monospace;';
					outputDiv.setText(JSON.stringify(entry.output, null, 2).substring(0, 200));
				}

				if (entry.error) {
					const errorDiv = entryDiv.createEl('div', { cls: 'log-error' });
					errorDiv.style.cssText = 'color: var(--text-error); margin-left: 16px;';
					errorDiv.setText(`Error: ${entry.error}`);
				}
			}

			// Add final result as assistant message
			if (execution.status === 'completed' && execution.variables) {
				const resultContent = JSON.stringify(execution.variables, null, 2);
				this.messages.push({
					role: 'assistant',
					content: `Workflow completed successfully!\n\n\`\`\`json\n${resultContent}\n\`\`\``
				});
			}

			new Notice(`Workflow ${execution.status}`);

		} catch (error: any) {
			statusEl.setText(`Error: ${error.message}`);
			statusEl.style.color = 'var(--text-error)';
			new Notice(`Workflow failed: ${error.message}`);
		}

		this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
	}

	private agentExecutionSteps: Array<{type: 'thought' | 'action' | 'observation', content: string, timestamp: number}> = [];
	private agentExecutionTraceEl: HTMLElement | null = null;

	private async processToolCalls(content: string, traceContainer?: HTMLElement, contentEl?: HTMLElement) {
		// Only process tool calls in agent mode, not in chat mode
		if (this.mode !== 'agent') {
			return false;
		}

		// Extract JSON tool calls from content
		const jsonBlockRegex = /```json\s*\n([\s\S]*?)\n```/g;
		const matches = [...content.matchAll(jsonBlockRegex)];

		// Track if any tools were executed
		let toolsExecuted = false;

		// Extract thought from content (text before tool call) - only in agent mode
		const thoughtMatch = content.match(/Thought:(.*?)(?:Action:|$)/s);
		if (thoughtMatch) {
			const thought = thoughtMatch[1].trim();
			if (thought) {
				this.agentExecutionSteps.push({
					type: 'thought',
					content: thought,
					timestamp: Date.now()
				});
			}
		}

		for (const match of matches) {
			try {
				const json = JSON.parse(match[1]);

				// Handle both formats: { "name": "tool_name", "arguments": {...} } and { "tool": "tool_name", "arguments": {...} }
				const toolName = json.name || json.tool;
				if (!toolName || typeof toolName !== 'string') {
					console.log('Skipping non-tool call JSON block:', json);
					continue;
				}

				// Ensure it has the right structure to be a ToolCall
				const toolCall: ToolCall = {
					name: toolName,
					arguments: typeof json.arguments === 'object' && json.arguments !== null ? json.arguments : {}
				};

				// Record action step
				this.agentExecutionSteps.push({
					type: 'action',
					content: `${toolCall.name}(${JSON.stringify(toolCall.arguments)})`,
					timestamp: Date.now()
				});

				// Execute tool
				const result = await this.toolManager.executeTool(toolCall);

				// Record observation step
				this.agentExecutionSteps.push({
					type: 'observation',
					content: result.success ? JSON.stringify(result.result, null, 2) : `Error: ${result.error}`,
					timestamp: Date.now()
				});

				// Update trace UI if container exists
				if (traceContainer) {
					this.updateExecutionTrace(traceContainer);
				}

				// Add tool result to messages for context
				this.messages.push({
					role: 'system',
					content: `Tool ${toolCall.name} result: ${result.success ? JSON.stringify(result.result) : result.error}`
				} as Message);

				toolsExecuted = true;

			} catch (error) {
				console.error('Tool call parsing error:', error);
				this.agentExecutionSteps.push({
					type: 'observation',
					content: `Error: ${error.message}`,
					timestamp: Date.now()
				});
			}
		}

		// If any tools were executed, continue the agent conversation with the new context
		if (toolsExecuted) {
			// Add a small delay to allow UI to update
			await new Promise(resolve => setTimeout(resolve, 100));

			// Continue the agent conversation by triggering another agent response
			await this.continueAgentConversation(traceContainer, contentEl);
		}

		return toolsExecuted;
	}

	private updateExecutionTrace(container: HTMLElement) {
		// Clear existing trace content
		container.empty();

		// Create timeline for execution steps
		const timeline = container.createDiv('agent-execution-timeline');

		this.agentExecutionSteps.forEach((step, index) => {
			const stepEl = timeline.createDiv(`agent-step agent-step-${step.type}`);

			// Step indicator
			const indicator = stepEl.createDiv('agent-step-indicator');
			if (step.type === 'thought') {
				indicator.innerHTML = 'üß†';
			} else if (step.type === 'action') {
				indicator.innerHTML = '‚ö°';
			} else {
				indicator.innerHTML = 'üëÅÔ∏è';
			}

			// Step content
			const contentEl = stepEl.createDiv('agent-step-content');

			// Step header
			const header = contentEl.createDiv('agent-step-header');
			header.createSpan({ text: step.type.charAt(0).toUpperCase() + step.type.slice(1), cls: 'agent-step-type' });

			const time = new Date(step.timestamp);
			const timeStr = time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
			header.createSpan({ text: timeStr, cls: 'agent-step-time' });

			// Step body
			const body = contentEl.createDiv('agent-step-body');
			if (step.type === 'action') {
				// Format action nicely
				const match = step.content.match(/^(\w+)\((.*)\)$/);
				if (match) {
					const toolName = match[1];
					const args = match[2];
					body.innerHTML = `<strong>${toolName}</strong><pre>${args}</pre>`;
				} else {
					body.setText(step.content);
				}
			} else if (step.type === 'observation') {
				// Format observation as code block
				const pre = body.createEl('pre');
				pre.setText(step.content);
			} else {
				body.setText(step.content);
			}
		});
	}

	private createAgentExecutionTraceContainer(messageBody: HTMLElement): HTMLElement {
		const traceContainer = messageBody.createDiv('agent-execution-trace-container');
		traceContainer.style.marginTop = '12px';

		// Collapsible header
		const header = traceContainer.createDiv('agent-execution-trace-header');
		header.innerHTML = `
			<span class="agent-trace-icon">‚ñ∂</span>
			<span class="agent-trace-title">Execution Trace</span>
			<span class="agent-trace-count">${this.agentExecutionSteps.length} steps</span>
		`;
		header.style.cursor = 'pointer';
		header.style.padding = '8px 12px';
		header.style.background = 'var(--background-secondary)';
		header.style.borderRadius = '6px';
		header.style.display = 'flex';
		header.style.alignItems = 'center';
		header.style.gap = '8px';
		header.style.fontWeight = '500';

		// Trace content (collapsed by default)
		const content = traceContainer.createDiv('agent-execution-trace-content');
		content.style.display = 'none';
		content.style.marginTop = '8px';
		content.style.padding = '12px';
		content.style.background = 'var(--background-primary)';
		content.style.borderRadius = '6px';
		content.style.border = '1px solid var(--background-modifier-border)';

		// Toggle on click
		let isExpanded = false;
		header.addEventListener('click', () => {
			isExpanded = !isExpanded;
			content.style.display = isExpanded ? 'block' : 'none';
			const icon = header.querySelector('.agent-trace-icon');
			if (icon) {
				icon.textContent = isExpanded ? '‚ñº' : '‚ñ∂';
			}
		});

		return content;
	}

	/**
	 * Extract and display the final answer from the agent's response
	 */
	private displayAgentFinalAnswer(contentEl: HTMLElement) {
		if (this.agentExecutionSteps.length === 0) {
			return; // No execution steps, nothing to display
		}

		// Get the last assistant message
		const lastMessage = this.messages[this.messages.length - 1];
		if (!lastMessage || lastMessage.role !== 'assistant') {
			return;
		}

		// Check if this message has no more tool calls (it's the final answer)
		const hasToolCall = lastMessage.content.includes('```json') && lastMessage.content.match(/```json\s*\n([\s\S]*?)\n```/);

		if (!hasToolCall) {
			// This is the final answer - extract clean content
			let finalAnswer = lastMessage.content;

			// Remove all tool call blocks
			finalAnswer = finalAnswer.replace(/```json[\s\S]*?```/g, '').trim();

			// Remove "Thought:" prefix if present
			finalAnswer = finalAnswer.replace(/^Thought:\s*/i, '').trim();

			// Remove "Observation:" prefix if present
			finalAnswer = finalAnswer.replace(/^Observation:\s*/i, '').trim();

			// Remove "Action:" and anything after it if present
			const actionIndex = finalAnswer.toLowerCase().indexOf('action:');
			if (actionIndex !== -1) {
				finalAnswer = finalAnswer.substring(0, actionIndex).trim();
			}

			if (finalAnswer) {
				// Update content to show only final answer
				contentEl.innerHTML = '';
				const finalAnswerEl = contentEl.createDiv('agent-final-answer');
				finalAnswerEl.innerHTML = `<h4>Final Answer</h4>`;
				try {
					const html = marked.parse(finalAnswer) as string;
					finalAnswerEl.innerHTML += html;
				} catch (error) {
					finalAnswerEl.createDiv().setText(finalAnswer);
				}

				// Save execution steps to the last assistant message
				lastMessage.agentExecutionSteps = [...this.agentExecutionSteps];
			}
		}
	}

	/**
	 * Continue the agent conversation after tool execution
	 */
	private async continueAgentConversation(traceContainer?: HTMLElement, contentEl?: HTMLElement) {
		console.log('[Agent] Continuing agent conversation after tool execution...');

		// Get the current config and model to make another call
		const selectedModel = this.modelSelect.value;
		if (!selectedModel) {
			console.error('[Agent] No model selected for continuation');
			return;
		}

		// Get config using the same method as the original code
		const config = ModelManager.findConfigForModelByProvider(selectedModel, this.plugin.settings.llmConfigs);

		if (!config) {
			console.error('[Agent] No active config found for continuation');
			return;
		}

		// Don't create a new message element - we'll continue in the trace
		let fullContent = '';

		try {
			// Build the chat request with all current messages (including tool results)
			const chatRequest = {
				model: selectedModel,
				messages: [...this.messages], // Use all messages including the tool results we just added
				temperature: this.temperature,
				maxTokens: this.maxTokens,
			};

			// Add system prompts and context if needed
			const finalMessages = [...chatRequest.messages];

			// Add system prompt if configured (use the same method as the original)
			const systemMessages = [];
			const systemPromptContent = this.plugin.settings.systemPrompts.find(p => p.id === this.plugin.settings.activeSystemPromptId)?.content;
			if (systemPromptContent) {
				systemMessages.push({
					role: 'system' as const,
					content: systemPromptContent
				});
			}

			// Add agent memory context if using an agent with memory
			if (this.plugin.settings.activeAgentId) {
				const agent = this.plugin.settings.agents.find(a => a.id === this.plugin.settings.activeAgentId);
				if (agent && agent.memoryType !== 'none' && this.currentConversationId) {
					const recentSummaries = this.memoryManager.getRecentSummaries(agent.id, 3);
					if (recentSummaries.length > 0) {
						const memoryContext = recentSummaries
							.map(s => `[Previous conversation: ${s.summary}]`)
							.join('\n');
						systemMessages.push({
							role: 'system' as const,
							content: `Previous conversation context:\n${memoryContext}`
						});
					}
				}
			}

			// Add system prompt for Agent mode (this is important to maintain agent behavior)
			if (this.mode === 'agent') {
				// Check if this is a generic agent mode (not a specific agent)
				const isGenericAgent = !this.plugin.settings.activeAgentId;
				
				// Only enable ReAct pattern for generic agent mode (not for specific agents)
				if (isGenericAgent) {
					// Enable think mode for ReAct agents by default
					this.enableThink = true;
					
					const toolsList = this.toolManager.getAllTools().map(tool =>
						`- ${tool.definition.name}: ${tool.definition.description}`
					).join('\n');

					systemMessages.push({
						role: 'system' as const,
						content: `You are a ReAct (Reasoning + Action) agent. You think step-by-step and take actions when needed to solve user queries.

Follow this ReAct pattern strictly:
Thought: First, think about what you need to do to solve the query
Action: Then, call a tool if needed with the proper arguments
Observation: You will receive the result of your action
Repeat: Continue thinking, acting, and observing until you can provide a final answer

Available tools:
${toolsList}

To call a tool, respond with a JSON block in this format:
\`\`\`json
{
  "name": "tool_name",
  "arguments": {
    "arg1": "value1",
    "arg2": "value2"
  }
}
\`\`\`

Always think before you act. Only call one tool at a time. After receiving the result, think about what to do next.

Example format:
Thought: I need to search for information about Obsidian plugins
Action: 
\`\`\`json
{
  "name": "web_search",
  "arguments": {
    "query": "Obsidian plugins tutorial"
  }
}
\`\`\`
Observation: [Tool result will appear here]
Thought: Based on the search results, I can now answer the user's question...

After calling a tool and receiving results, you can continue the conversation or call another tool if needed.`
					});
				} else {
					// For specific agents (not generic), use standard agent instructions without ReAct pattern
					const toolsList = this.toolManager.getAllTools().map(tool =>
						`- ${tool.definition.name}: ${tool.definition.description}`
					).join('\n');

					systemMessages.push({
						role: 'system' as const,
						content: `You are an AI agent with access to tools. You can call tools to help answer the user's questions.

Available tools:
${toolsList}

To call a tool, respond with a JSON block in this format:
\`\`\`json
{
  "name": "tool_name",
  "arguments": {
    "arg1": "value1",
    "arg2": "value2"
  }
}
\`\`\`

After calling a tool, you will receive the result and can continue the conversation or call another tool if needed.`
					});
				}
			}

			// Insert system messages at the beginning
			const allMessages = [...systemMessages, ...chatRequest.messages];

			// Make the API call with the updated messages
			// Use streaming like the main implementation
			const provider = ProviderFactory.createProvider(config);
			
			// Streaming implementation - collect content silently
			await provider.streamChat({
				...chatRequest,
				messages: allMessages
			}, async (chunk: any) => {
				if (chunk.content) {
					fullContent += chunk.content;
				}

				if (chunk.done) {
					// Add the assistant's response to the messages
					this.messages.push({
						role: 'assistant',
						content: fullContent,
						model: selectedModel  // Use just the model ID, not provider:model
					} as Message);

					// In Agent mode, check if the agent wants to call more tools with the new context
					if (this.mode === 'agent' && traceContainer) {
						// Wait briefly for the UI to update
						await new Promise(resolve => setTimeout(resolve, 50));
						// Process any new tool calls that might have been generated
						await this.processToolCalls(fullContent, traceContainer, contentEl);
					}

					// Save conversation after successful message
					await this.saveCurrentConversation();

					// Save agent memory if using an agent with memory
					if (this.plugin.settings.activeAgentId && this.currentConversationId) {
						const agent = this.plugin.settings.agents.find(a => a.id === this.plugin.settings.activeAgentId);
						if (agent && agent.memoryType !== 'none') {
							await this.saveAgentMemory(agent, this.messages);
						}
					}
				}
			});
		} catch (error) {
			console.error('[Agent] Error continuing agent conversation:', error);
			new Notice('Error continuing agent conversation: ' + error.message);
		}
	}

	private async clearChat() {
		if (!confirm('Clear all messages in this conversation?')) return;

		this.messages = [];
		this.chatContainer.empty();
		await this.saveCurrentConversation();
	}

	private async attachFile() {
		// Get all markdown files in vault
		const files = this.app.vault.getMarkdownFiles();

		if (files.length === 0) {
			new Notice('No files found in vault');
			return;
		}

		// Create a simple file picker menu
		const menu = new Menu();
		files.slice(0, 20).forEach(file => {
			menu.addItem((item) => {
				item.setTitle(file.path)
					.setIcon('document')
					.onClick(async () => {
						const content = await this.app.vault.read(file);
						this.currentAttachments.push({
							type: 'file',
							name: file.name,
							path: file.path,
							content: content
						});
						this.updateAttachmentPreview();
						new Notice(`Attached: ${file.name}`);
					});
			});
		});

		menu.showAtMouseEvent(event as MouseEvent);
	}

	private async attachImage() {
		new SearchableImageModal(this.app, async (selectedFiles: TFile[]) => {
			for (const file of selectedFiles) {
				const arrayBuffer = await this.app.vault.readBinary(file);
				const base64 = this.arrayBufferToBase64(arrayBuffer);
				const dataUrl = `data:image/${file.extension};base64,${base64}`;

				this.currentAttachments.push({
					type: 'image',
					name: file.name,
					path: file.path,
					content: dataUrl
				});
			}
			this.updateAttachmentPreview();
			if (selectedFiles.length > 0) {
				new Notice(`Attached ${selectedFiles.length} image(s)`);
			}
		}).open();
	}

	private arrayBufferToBase64(buffer: ArrayBuffer): string {
		let binary = '';
		const bytes = new Uint8Array(buffer);
		for (let i = 0; i < bytes.byteLength; i++) {
			binary += String.fromCharCode(bytes[i]);
		}
		return window.btoa(binary);
	}

	private updateAttachmentPreview() {
		if (!this.attachmentContainer) return;

		this.attachmentContainer.empty();

		if (this.currentAttachments.length === 0) {
			this.attachmentContainer.style.display = 'none';
			return;
		}

		this.attachmentContainer.style.display = 'flex';
		this.attachmentContainer.style.gap = '8px';
		this.attachmentContainer.style.padding = '8px';
		this.attachmentContainer.style.background = 'var(--background-secondary)';
		this.attachmentContainer.style.borderRadius = '4px';
		this.attachmentContainer.style.flexWrap = 'wrap';
		this.attachmentContainer.style.marginBottom = '8px';

		this.currentAttachments.forEach((att, index) => {
			const attPreview = this.attachmentContainer!.createDiv('attachment-preview-item');
			attPreview.style.position = 'relative';
			attPreview.style.padding = '8px';
			attPreview.style.background = 'var(--background-primary)';
			attPreview.style.borderRadius = '4px';
			attPreview.style.display = 'flex';
			attPreview.style.alignItems = 'center';
			attPreview.style.gap = '8px';

			if (att.type === 'image' && att.content) {
				const img = attPreview.createEl('img');
				img.src = att.content;
				img.alt = att.name;
				img.style.width = '40px';
				img.style.height = '40px';
				img.style.objectFit = 'cover';
				img.style.borderRadius = '4px';
			} else {
				attPreview.createSpan({ text: att.type === 'image' ? 'üñºÔ∏è' : 'üìé' });
			}

			attPreview.createSpan({ text: att.name });

			// Remove button
			const removeBtn = attPreview.createEl('button', { text: '√ó' });
			removeBtn.style.marginLeft = 'auto';
			removeBtn.style.padding = '0 6px';
			removeBtn.style.border = 'none';
			removeBtn.style.background = 'transparent';
			removeBtn.style.cursor = 'pointer';
			removeBtn.style.fontSize = '20px';
			removeBtn.style.color = 'var(--text-error)';
			removeBtn.addEventListener('click', () => {
				this.currentAttachments.splice(index, 1);
				this.updateAttachmentPreview();
			});
		});
	}

	private addStyles() {
		const styleEl = document.createElement('style');
		styleEl.textContent = `
			.intelligence-assistant-chat-container {
				display: flex;
				flex-direction: column;
				height: 100%;
				padding: 0;
			}

			.chat-main-layout {
				display: flex;
				height: 100%;
				gap: 0;
				position: relative;
			}

			.conversation-list-floating {
				position: absolute;
				left: 0;
				top: 0;
				bottom: 0;
				width: 280px;
				background: var(--background-secondary);
				border-right: 1px solid var(--background-modifier-border);
				box-shadow: 2px 0 8px rgba(0, 0, 0, 0.1);
				z-index: 100;
				display: flex;
				flex-direction: column;
			}

			.conversation-list-header {
				padding: 10px;
				border-bottom: 1px solid var(--background-modifier-border);
				display: flex;
				justify-content: space-between;
				align-items: center;
			}

			.conversation-list-header h3 {
				margin: 0;
				font-size: 14px;
				font-weight: 600;
			}

			.conversation-header-buttons {
				display: flex;
				gap: 4px;
			}

			.pin-conversation-btn,
			.new-conversation-btn {
				width: 24px;
				height: 24px;
				padding: 0;
				border-radius: 4px;
				border: 1px solid var(--background-modifier-border);
				background: var(--background-primary);
				color: var(--text-normal);
				cursor: pointer;
				font-size: 14px;
				line-height: 1;
			}

			.pin-conversation-btn:hover,
			.new-conversation-btn:hover {
				background: var(--background-modifier-hover);
			}

			.conversation-list-content {
				flex: 1;
				overflow-y: auto;
			}

			.conversation-item {
				padding: 10px;
				border-bottom: 1px solid var(--background-modifier-border);
				cursor: pointer;
				transition: background-color 0.1s;
			}

			.conversation-item:hover {
				background: var(--background-modifier-hover);
			}

			.conversation-item.active {
				background: var(--background-modifier-active-hover);
			}

			.conversation-title {
				font-size: 13px;
				color: var(--text-normal);
				overflow: hidden;
				text-overflow: ellipsis;
				white-space: nowrap;
			}

			.empty-state {
				padding: 20px;
				text-align: center;
				color: var(--text-muted);
				font-size: 12px;
			}

			.main-chat-area {
				flex: 1;
				width: 100%;
				display: flex;
				flex-direction: column;
				padding: 10px;
			}

			.chat-header {
				display: flex;
				align-items: center;
				gap: 10px;
				padding: 10px 0;
				border-bottom: 1px solid var(--background-modifier-border);
				margin-bottom: 10px;
				flex-wrap: wrap;
			}

			.model-selector {
				display: flex;
				align-items: center;
				gap: 8px;
				flex: 1;
			}

			.model-selector select {
				flex: 1;
				min-width: 150px;
				padding: 6px 10px;
				border-radius: 4px;
				border: 1px solid var(--background-modifier-border);
				background: var(--background-primary);
				color: var(--text-normal);
				font-weight: 500;
			}

			.provider-selector {
				display: flex;
				align-items: center;
				gap: 8px;
			}

			.provider-selector span {
				font-size: 12px;
				color: var(--text-muted);
			}

			.provider-selector select {
				padding: 4px 8px;
				border-radius: 4px;
				border: 1px solid var(--background-modifier-border);
				background: var(--background-primary);
				color: var(--text-normal);
				font-size: 12px;
			}

			.params-row {
				display: flex;
				gap: 20px;
				padding: 10px 0;
				border-bottom: 1px solid var(--background-modifier-border);
				margin-bottom: 10px;
			}

			.param-control {
				display: flex;
				align-items: center;
				gap: 8px;
			}

			.param-label {
				font-size: 12px;
				color: var(--text-muted);
				white-space: nowrap;
			}

			.param-value {
				font-size: 12px;
				color: var(--text-normal);
				min-width: 30px;
				text-align: center;
			}

			.param-control input[type="range"] {
				width: 120px;
			}

			.param-control input[type="number"] {
				width: 100px;
				padding: 4px 8px;
				border-radius: 4px;
				border: 1px solid var(--background-modifier-border);
				background: var(--background-primary);
				color: var(--text-normal);
				font-size: 12px;
			}

			.chat-messages {
				flex: 1;
				overflow-y: auto;
				padding: 12px 16px;
				display: flex;
				flex-direction: column;
				gap: 12px;
			}

			.chat-message {
				display: flex;
				width: 100%;
			}

			.message-user .message-row {
				flex-direction: row-reverse;
			}

			.message-row {
				display: flex;
				gap: 10px;
				width: 100%;
				max-width: 100%;
			}

			.message-avatar {
				flex-shrink: 0;
				width: 28px;
				height: 28px;
				border-radius: 50%;
				background: var(--background-modifier-border);
				display: flex;
				align-items: center;
				justify-content: center;
				color: var(--text-muted);
			}

			.message-avatar svg {
				width: 16px;
				height: 16px;
			}

			.message-user .message-avatar {
				background: var(--interactive-accent);
				color: white;
			}

			.message-assistant .message-avatar {
				background: var(--background-secondary);
				border: 1px solid var(--background-modifier-border);
			}

			/* Tool execution messages */
			.message-tool {
				padding: 12px;
				margin: 12px 0;
				background: var(--background-primary);
				border: 1px solid var(--background-modifier-border);
				border-radius: 6px;
			}

			.tool-execution {
				display: flex;
				flex-direction: column;
				gap: 8px;
			}

			.tool-icon {
				font-size: 20px;
			}

			.tool-name {
				font-weight: 600;
				color: var(--text-accent);
				font-size: 13px;
			}

			.tool-args {
				font-family: var(--font-monospace);
				font-size: 11px;
				color: var(--text-muted);
				white-space: pre;
				background: var(--background-secondary);
				padding: 8px;
				border-radius: 4px;
			}

			.tool-result {
				margin-top: 8px;
				padding: 8px;
				border-radius: 4px;
			}

			.tool-success {
				background: rgba(0, 255, 0, 0.1);
				border-left: 3px solid var(--text-success);
			}

			.tool-error {
				background: rgba(255, 0, 0, 0.1);
				border-left: 3px solid var(--text-error);
			}

			.tool-result pre {
				font-family: var(--font-monospace);
				font-size: 11px;
				margin: 4px 0 0 0;
				white-space: pre-wrap;
			}

			.message-body {
				flex: 1;
				min-width: 0;
			}

			.message-meta {
				display: flex;
				align-items: center;
				gap: 6px;
				margin-bottom: 4px;
			}

			.message-name {
				font-weight: 600;
				font-size: 12px;
				color: var(--text-normal);
			}

			.message-timestamp {
				font-size: 10px;
				color: var(--text-faint);
			}

			.message-actions {
				display: flex;
				gap: 2px;
				margin-top: 4px;
				opacity: 0;
				transition: opacity 0.15s;
			}

			.message-body:hover .message-actions {
				opacity: 1;
			}

			.msg-action-btn {
				padding: 3px 6px;
				border: none;
				background: transparent;
				color: var(--text-muted);
				cursor: pointer;
				border-radius: 3px;
				display: flex;
				align-items: center;
				gap: 2px;
				font-size: 11px;
				transition: all 0.15s;
			}

			.msg-action-btn:hover {
				background: var(--background-modifier-hover);
				color: var(--text-normal);
			}

			.msg-action-btn svg {
				width: 14px;
				height: 14px;
			}

			.message-content {
				line-height: 1.5;
				word-wrap: break-word;
				font-size: 13px;
				white-space: normal;
			}

			.message-content p {
				margin: 0.2em 0;
			}

			.message-content p:first-child {
				margin-top: 0;
			}

			.message-content p:last-child {
				margin-bottom: 0;
			}

			.message-content p:empty {
				display: none;
			}

			.message-content code {
				background: var(--background-primary);
				padding: 2px 6px;
				border-radius: 4px;
				font-family: var(--font-monospace);
				font-size: 0.9em;
			}

			.message-content pre {
				background: var(--background-primary);
				padding: 12px;
				border-radius: 6px;
				overflow-x: auto;
				margin: 8px 0;
			}

			.message-content pre code {
				background: none;
				padding: 0;
			}

			.message-content ul, .message-content ol {
				margin: 0.5em 0;
				padding-left: 1.5em;
			}

			.message-content blockquote {
				border-left: 3px solid var(--background-modifier-border);
				padding-left: 12px;
				margin: 8px 0;
				opacity: 0.8;
			}

			.message-attachments {
				margin-top: 6px;
				display: flex;
				flex-direction: column;
				gap: 4px;
			}

			.attachment-item {
				padding: 6px;
				background: var(--background-modifier-border);
				border-radius: 4px;
				font-size: 0.85em;
			}

			.chat-input-container {
				padding: 10px;
				background: var(--background-secondary);
				border-top: 1px solid var(--background-modifier-border);
				display: flex;
				flex-direction: column;
				gap: 8px;
			}

			/* Bottom controls - 3 sections layout */
			.input-bottom-controls {
				display: flex;
				align-items: center;
				justify-content: space-between;
				gap: 8px;
			}

			.bottom-left-controls {
				display: flex;
				align-items: center;
				gap: 8px;
				flex: 1;
			}

			.bottom-middle-controls {
				display: flex;
				align-items: center;
				gap: 8px;
			}

			.bottom-right-controls {
				display: flex;
				align-items: center;
				gap: 8px;
			}

			.mode-selector {
				padding: 4px 8px;
				border: 1px solid var(--background-modifier-border);
				border-radius: 4px;
				background: var(--background-primary);
				color: var(--text-normal);
				font-size: 11px;
				cursor: pointer;
				min-width: 90px;
			}

			.mode-options {
				display: flex;
				align-items: center;
				gap: 8px;
			}

			.chat-mode-options, .agent-mode-options {
				display: flex;
				align-items: center;
				gap: 8px;
			}

			.checkbox-container {
				display: flex;
				align-items: center;
				gap: 4px;
			}

			.checkbox-container input[type="checkbox"] {
				cursor: pointer;
				margin: 0;
			}

			.checkbox-container label {
				font-size: 11px;
				color: var(--text-muted);
				user-select: none;
				cursor: pointer;
			}

			/* Toggle Button Styles */
			.toggle-btn {
				display: flex;
				align-items: center;
				gap: 4px;
				padding: 4px 10px;
				border-radius: 12px;
				border: 1px solid var(--background-modifier-border);
				background: var(--background-primary);
				color: var(--text-muted);
				cursor: pointer;
				font-size: 11px;
				transition: all 0.2s ease;
				outline: none;
			}

			.toggle-btn:hover {
				background: var(--background-modifier-hover);
				border-color: var(--interactive-accent);
			}

			.toggle-btn.active {
				background: var(--interactive-accent);
				color: white;
				border-color: var(--interactive-accent);
				box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
			}

			.toggle-btn .toggle-icon {
				font-size: 14px;
				line-height: 1;
			}

			.toggle-btn.active .toggle-icon {
				filter: brightness(1.1);
			}

			.toggle-btn .toggle-label {
				font-weight: 500;
			}

			.tools-label {
				font-size: 11px;
				color: var(--text-muted);
			}

			/* Workflow Execution Styles */
			.message-workflow {
				padding: 12px;
				background: var(--background-secondary);
				border-left: 4px solid var(--interactive-accent);
				border-radius: 4px;
				margin-bottom: 12px;
			}

			.workflow-execution {
				font-size: 13px;
			}

			.workflow-header {
				display: flex;
				align-items: center;
				gap: 8px;
				margin-bottom: 12px;
				font-weight: 600;
			}

			.workflow-icon {
				font-size: 20px;
			}

			.workflow-status {
				padding: 6px 12px;
				background: var(--background-primary);
				border-radius: 4px;
				font-size: 12px;
				margin-bottom: 12px;
			}

			.workflow-log {
				max-height: 400px;
				overflow-y: auto;
			}

			.log-entry {
				font-size: 11px;
				padding: 4px 0;
				border-bottom: 1px solid var(--background-modifier-border);
			}

			.log-action {
				color: var(--text-normal);
			}

			.log-output {
				color: var(--text-muted);
				margin-left: 16px;
				font-family: monospace;
				font-size: 10px;
			}

			.log-error {
				color: var(--text-error);
				margin-left: 16px;
			}

			/* Part 1: Reference area */
			.input-reference-area {
				background: var(--background-primary);
				border: 1px solid var(--background-modifier-border);
				border-radius: 6px;
				padding: 8px;
			}

			.reference-list {
				display: flex;
				flex-direction: column;
				gap: 4px;
			}

			.reference-item {
				display: flex;
				align-items: center;
				gap: 6px;
				padding: 4px 8px;
				background: var(--background-secondary);
				border-radius: 4px;
				font-size: 12px;
			}

			.reference-icon {
				flex-shrink: 0;
			}

			.reference-path {
				flex: 1;
				overflow: hidden;
				text-overflow: ellipsis;
				white-space: nowrap;
			}

			.reference-remove-btn {
				padding: 0 4px;
				border: none;
				background: transparent;
				color: var(--text-error);
				cursor: pointer;
				font-size: 16px;
				line-height: 1;
			}

			.reference-remove-btn:hover {
				background: var(--background-modifier-hover);
				border-radius: 2px;
			}

			.add-reference-btn {
				display: inline-flex;
				align-items: center;
				gap: 4px;
				padding: 6px 10px;
				background: var(--interactive-normal);
				border: 1px solid var(--background-modifier-border);
				border-radius: 4px;
				cursor: pointer;
				font-size: 12px;
				color: var(--text-muted);
				transition: all 0.2s;
			}

			.add-reference-btn:hover {
				background: var(--interactive-hover);
				color: var(--text-normal);
			}

			.add-reference-btn svg {
				width: 16px;
				height: 16px;
			}

			/* Message references (displayed in sent messages) */
			.message-references {
				display: flex;
				flex-wrap: wrap;
				gap: 6px;
				margin-top: 8px;
			}

			.reference-badge {
				display: inline-flex;
				align-items: center;
				gap: 4px;
				padding: 3px 8px;
				background: var(--background-primary);
				border: 1px solid var(--background-modifier-border);
				border-radius: 12px;
				font-size: 11px;
				color: var(--text-muted);
				transition: all 0.2s;
			}

			.reference-badge:hover {
				background: var(--background-modifier-hover);
				color: var(--text-normal);
				border-color: var(--interactive-accent);
			}

			/* Part 2: Text input */
			.chat-input {
				width: 100%;
				min-height: 60px;
				max-height: 120px;
				padding: 10px;
				border: 1px solid var(--background-modifier-border);
				border-radius: 6px;
				background: var(--background-primary);
				color: var(--text-normal);
				resize: none;
				font-family: inherit;
				font-size: 13px;
				line-height: 1.5;
				outline: none;
				transition: border-color 0.2s;
			}

			.chat-input:focus {
				border-color: var(--interactive-accent);
			}

			.chat-input::placeholder {
				color: var(--text-muted);
			}


			.input-control-btn {
				display: flex;
				align-items: center;
				justify-content: center;
				padding: 6px 10px;
				border: 1px solid var(--background-modifier-border);
				background: var(--background-primary);
				color: var(--text-muted);
				cursor: pointer;
				border-radius: 4px;
				transition: all 0.2s;
			}

			.input-control-btn:hover {
				background: var(--background-modifier-hover);
				color: var(--text-normal);
			}

			.input-control-btn svg {
				width: 18px;
				height: 18px;
			}

			.attachment-preview {
				flex: 1;
				display: flex;
				gap: 6px;
				flex-wrap: wrap;
			}

			.attachment-preview-item {
				display: flex;
				align-items: center;
				gap: 6px;
				padding: 4px 8px;
				background: var(--background-secondary);
				border: 1px solid var(--background-modifier-border);
				border-radius: 4px;
				font-size: 11px;
			}

			.send-info {
				font-size: 11px;
				color: var(--text-muted);
			}

			.send-info kbd {
				padding: 2px 6px;
				background: var(--background-primary);
				border: 1px solid var(--background-modifier-border);
				border-radius: 3px;
				font-family: var(--font-monospace);
				font-size: 10px;

	/* RAG Sources Display */
	.rag-sources-container {
		margin-top: 12px;
		padding: 12px;
		background: var(--background-primary);
		border: 1px solid var(--background-modifier-border);
		border-radius: 6px;
	}

	.rag-sources-header {
		font-weight: 600;
		color: var(--text-accent);
		margin-bottom: 8px;
		font-size: 12px;
		display: flex;
		align-items: center;
		gap: 6px;
	}

	.rag-sources-grid {
		display: flex;
		flex-direction: column;
		gap: 8px;
	}

	.rag-source-card {
		padding: 10px;
		border: 1px solid var(--background-modifier-border);
		border-radius: 6px;
		background: var(--background-secondary);
		transition: all 0.2s ease;
		cursor: pointer;
	}

	.rag-source-card:hover {
		border-color: var(--interactive-accent);
		background: var(--background-modifier-hover);
		transform: translateY(-1px);
		box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
	}

	.rag-source-header {
		display: flex;
		justify-content: space-between;
		align-items: flex-start;
		margin-bottom: 6px;
	}

	.rag-source-title {
		font-weight: 600;
		font-size: 13px;
		color: var(--text-normal);
		flex: 1;
	}

	.rag-source-similarity {
		font-size: 11px;
		font-weight: 600;
		background: var(--background-primary);
		padding: 2px 6px;
		border-radius: 10px;
		min-width: 40px;
		text-align: center;
	}

	.rag-source-path {
		font-size: 11px;
		color: var(--text-muted);
		margin-bottom: 6px;
		word-break: break-all;
	}

	.rag-source-content {
		font-size: 12px;
		color: var(--text-muted);
		line-height: 1.4;
		background: var(--background-primary);
		padding: 8px;
		border-radius: 4px;
		border-left: 2px solid var(--interactive-accent);
	}

	.rag-source-content:hover {
		background: var(--background-secondary);
	}
			}
		`;
		document.head.appendChild(styleEl);
	}

	async onClose() {
		// Cleanup
		if (this.ragManager) {
			await this.ragManager.destroy();
		}
	}
}

// Modal for text input
class TextInputModal extends Modal {
	result: string;
	onSubmit: (result: string) => void;
	placeholder: string;
	defaultValue: string;
	title: string;

	constructor(app: any, title: string, placeholder: string, defaultValue: string, onSubmit: (result: string) => void) {
		super(app);
		this.title = title;
		this.placeholder = placeholder;
		this.defaultValue = defaultValue;
		this.onSubmit = onSubmit;
	}

	onOpen() {
		const { contentEl } = this;

		contentEl.createEl('h2', { text: this.title });

		new Setting(contentEl)
			.setName('Name')
			.addText(text => {
				text.setPlaceholder(this.placeholder)
					.setValue(this.defaultValue)
					.onChange(value => {
						this.result = value;
					});
				text.inputEl.focus();
				text.inputEl.select();
				// Submit on Enter
				text.inputEl.addEventListener('keydown', (e) => {
					if (e.key === 'Enter') {
						e.preventDefault();
						this.close();
						this.onSubmit(this.result || this.defaultValue);
					}
				});
			});

		new Setting(contentEl)
			.addButton(btn => btn
				.setButtonText('Create')
				.setCta()
				.onClick(() => {
					this.close();
					this.onSubmit(this.result || this.defaultValue);
				}))
			.addButton(btn => btn
				.setButtonText('Cancel')
				.onClick(() => {
					this.close();
				}));
	}

	onClose() {
		const { contentEl } = this;
		contentEl.empty();
	}
}

class SearchableReferenceModal extends Modal {
	private onChooseItems: (items: (TFile | TFolder)[]) => void;
	private searchInput: HTMLInputElement;
	private resultsContainer: HTMLElement;
	private allItems: (TFile | TFolder)[];
	private selectedItems: (TFile | TFolder)[] = [];

	constructor(app: App, onChooseItems: (items: (TFile | TFolder)[]) => void) {
		super(app);
		this.onChooseItems = onChooseItems;
		
		// Get all files and folders
		const allFiles = app.vault.getAllLoadedFiles();
		this.allItems = allFiles.filter(f => f instanceof TFile || f instanceof TFolder) as (TFile | TFolder)[];
	}

	onOpen() {
		const { contentEl } = this;
		contentEl.addClass('searchable-reference-modal');

		contentEl.createEl('h2', { text: 'Add References' });

		// Search input
		this.searchInput = contentEl.createEl('input', {
			type: 'text',
			placeholder: 'Search files and folders...'
		});
		this.searchInput.style.width = '100%';
		this.searchInput.style.padding = '8px';
		this.searchInput.style.marginBottom = '10px';
		this.searchInput.style.border = '1px solid var(--background-modifier-border)';
		this.searchInput.style.borderRadius = '4px';

		// Results container
		this.resultsContainer = contentEl.createDiv();
		this.resultsContainer.style.maxHeight = '400px';
		this.resultsContainer.style.overflowY = 'auto';

		// Initial display of all items
		this.displayItems(this.allItems);

		// Add search event listener
		this.searchInput.addEventListener('input', (e) => {
			const query = (e.target as HTMLInputElement).value.toLowerCase();
			const filteredItems = this.allItems.filter(item => 
				item.path.toLowerCase().includes(query)
			);
			this.displayItems(filteredItems);
		});

		// Add Enter key support for the search input
		this.searchInput.addEventListener('keydown', (e) => {
			if (e.key === 'Enter' && this.selectedItems.length > 0) {
				this.close();
				this.onChooseItems(this.selectedItems);
			}
		});

		// Add button container with actions
		const buttonContainer = contentEl.createDiv();
		buttonContainer.style.display = 'flex';
		buttonContainer.style.justifyContent = 'space-between';
		buttonContainer.style.marginTop = '10px';
		
		const selectAllButton = buttonContainer.createEl('button', { text: 'Select All' });
		selectAllButton.addEventListener('click', () => {
			this.selectedItems = [...this.allItems];
			this.updateDisplay();
		});
		
		const selectNoneButton = buttonContainer.createEl('button', { text: 'Select None' });
		selectNoneButton.addEventListener('click', () => {
			this.selectedItems = [];
			this.updateDisplay();
		});
		
		const addButton = buttonContainer.createEl('button', { text: 'Add Selected' });
		addButton.addClass('mod-cta');
		addButton.addEventListener('click', () => {
			this.close();
			this.onChooseItems(this.selectedItems);
		});
	}

	private displayItems(items: (TFile | TFolder)[]) {
		this.resultsContainer.empty();
		
		if (items.length === 0) {
			this.resultsContainer.createDiv({ text: 'No matching files or folders found.' });
			return;
		}

		items.forEach(item => {
			const itemEl = this.resultsContainer.createDiv('reference-item');
			itemEl.style.display = 'flex';
			itemEl.style.alignItems = 'center';
			itemEl.style.padding = '6px';
			itemEl.style.borderBottom = '1px solid var(--background-modifier-border)';
			itemEl.style.cursor = 'pointer';
			
			if (this.selectedItems.some(selected => selected.path === item.path)) {
				itemEl.style.backgroundColor = 'var(--background-modifier-active)';
			}
			
			// Add icon
			const iconEl = itemEl.createDiv();
			iconEl.style.marginRight = '8px';
			iconEl.setText(item instanceof TFolder ? 'üìÅ' : 'üìÑ');
			
			// Add path text
			const textEl = itemEl.createDiv();
			textEl.style.flex = '1';
			textEl.setText(item.path);
			
			// Add click event to toggle selection
			itemEl.addEventListener('click', () => {
				const isSelected = this.selectedItems.some(selected => selected.path === item.path);
				
				if (isSelected) {
					// Remove from selection
					this.selectedItems = this.selectedItems.filter(selected => selected.path !== item.path);
				} else {
					// Add to selection
					this.selectedItems.push(item);
				}
				
				this.updateDisplay();
			});
		});
	}
	
	private updateDisplay() {
		// Refresh the display to show selection state
		const query = this.searchInput.value.toLowerCase();
		const currentItems = this.allItems.filter(item => 
			item.path.toLowerCase().includes(query)
		);
		this.displayItems(currentItems);
	}

	onClose() {
		const { contentEl } = this;
		contentEl.empty();
	}
}

class SearchableImageModal extends Modal {
	private onChooseFiles: (files: TFile[]) => void;
	private searchInput: HTMLInputElement;
	private resultsContainer: HTMLElement;
	private allImageFiles: TFile[];
	private selectedFiles: TFile[] = [];

	constructor(app: App, onChooseFiles: (files: TFile[]) => void) {
		super(app);
		this.onChooseFiles = onChooseFiles;
		
		// Get all image files
		const files = app.vault.getFiles();
		this.allImageFiles = files.filter(f =>
			f.extension === 'png' || f.extension === 'jpg' ||
			f.extension === 'jpeg' || f.extension === 'gif' || f.extension === 'webp'
		) as TFile[];
	}

	onOpen() {
		const { contentEl } = this;
		contentEl.addClass('searchable-image-modal');

		contentEl.createEl('h2', { text: 'Attach Images' });

		// Search input
		this.searchInput = contentEl.createEl('input', {
			type: 'text',
			placeholder: 'Search images...'
		});
		this.searchInput.style.width = '100%';
		this.searchInput.style.padding = '8px';
		this.searchInput.style.marginBottom = '10px';
		this.searchInput.style.border = '1px solid var(--background-modifier-border)';
		this.searchInput.style.borderRadius = '4px';

		// Results container
		this.resultsContainer = contentEl.createDiv();
		this.resultsContainer.style.maxHeight = '400px';
		this.resultsContainer.style.overflowY = 'auto';

		// Initial display of all images
		this.displayImages(this.allImageFiles);

		// Add search event listener
		this.searchInput.addEventListener('input', (e) => {
			const query = (e.target as HTMLInputElement).value.toLowerCase();
			const filteredFiles = this.allImageFiles.filter((file: TFile) => 
				file.path.toLowerCase().includes(query)
			);
			this.displayImages(filteredFiles);
		});

		// Add Enter key support for the search input
		this.searchInput.addEventListener('keydown', (e) => {
			if (e.key === 'Enter' && this.selectedFiles.length > 0) {
				this.close();
				this.onChooseFiles(this.selectedFiles);
			}
		});

		// Add button container with actions
		const buttonContainer = contentEl.createDiv();
		buttonContainer.style.display = 'flex';
		buttonContainer.style.justifyContent = 'space-between';
		buttonContainer.style.marginTop = '10px';
		
		const selectAllButton = buttonContainer.createEl('button', { text: 'Select All' });
		selectAllButton.addEventListener('click', () => {
			this.selectedFiles = [...this.allImageFiles];
			this.updateDisplay();
		});
		
		const selectNoneButton = buttonContainer.createEl('button', { text: 'Select None' });
		selectNoneButton.addEventListener('click', () => {
			this.selectedFiles = [];
			this.updateDisplay();
		});
		
		const addButton = buttonContainer.createEl('button', { text: 'Add Selected' });
		addButton.addClass('mod-cta');
		addButton.addEventListener('click', () => {
			this.close();
			this.onChooseFiles(this.selectedFiles);
		});
	}

	private displayImages(files: TFile[]) {
		this.resultsContainer.empty();
		
		if (files.length === 0) {
			this.resultsContainer.createDiv({ text: 'No matching images found.' });
			return;
		}

		files.forEach(file => {
			const itemEl = this.resultsContainer.createDiv('image-item');
			itemEl.style.display = 'flex';
			itemEl.style.alignItems = 'center';
			itemEl.style.padding = '6px';
			itemEl.style.borderBottom = '1px solid var(--background-modifier-border)';
			itemEl.style.cursor = 'pointer';
			
			if (this.selectedFiles.some(selected => selected.path === file.path)) {
				itemEl.style.backgroundColor = 'var(--background-modifier-active)';
			}
			
			// Add icon
			const iconEl = itemEl.createDiv();
			iconEl.style.marginRight = '8px';
			iconEl.setText('üñºÔ∏è');
			
			// Add path text
			const textEl = itemEl.createDiv();
			textEl.style.flex = '1';
			textEl.setText(file.path);
			
			// Add click event to toggle selection
			itemEl.addEventListener('click', () => {
				const isSelected = this.selectedFiles.some(selected => selected.path === file.path);
				
				if (isSelected) {
					// Remove from selection
					this.selectedFiles = this.selectedFiles.filter(selected => selected.path !== file.path);
				} else {
					// Add to selection
					this.selectedFiles.push(file);
				}
				
				this.updateDisplay();
			});
		});
	}
	
	private updateDisplay() {
		// Refresh the display to show selection state
		const query = this.searchInput.value.toLowerCase();
		const currentFiles = this.allImageFiles.filter((file: TFile) => 
			file.path.toLowerCase().includes(query)
		);
		this.displayImages(currentFiles);
	}

	onClose() {
		const { contentEl } = this;
		contentEl.empty();
	}
}


class SingleFileSelectionModal extends Modal {
	private onChooseFile: (file: TFile | null) => void;
	private searchInput: HTMLInputElement;
	private resultsContainer: HTMLElement;
	private allFiles: TFile[];
	private selectedFile: TFile | null = null;

	constructor(app: App, onChooseFile: (file: TFile | null) => void) {
		super(app);
		this.onChooseFile = onChooseFile;
		
		// Get all markdown files
		const files = app.vault.getFiles();
		this.allFiles = files.filter(f => f.extension === "md") as TFile[];
	}

	onOpen() {
		const { contentEl } = this;
		contentEl.addClass("single-file-selection-modal");

		contentEl.createEl("h2", { text: "Insert to Note" });

		// Search input
		this.searchInput = contentEl.createEl("input", {
			type: "text",
			placeholder: "Search notes..."
		});
		this.searchInput.style.width = "100%";
		this.searchInput.style.padding = "8px";
		this.searchInput.style.marginBottom = "10px";
		this.searchInput.style.border = "1px solid var(--background-modifier-border)";
		this.searchInput.style.borderRadius = "4px";

		// Results container
		this.resultsContainer = contentEl.createDiv();
		this.resultsContainer.style.maxHeight = "400px";
		this.resultsContainer.style.overflowY = "auto";

		// Initial display of all items
		this.displayFiles(this.allFiles);

		// Add search event listener
		this.searchInput.addEventListener("input", (e) => {
			const query = (e.target as HTMLInputElement).value.toLowerCase();
			const filteredFiles = this.allFiles.filter(file => 
				file.path.toLowerCase().includes(query)
			);
			this.displayFiles(filteredFiles);
		});

		// Add Enter key support for the search input
		this.searchInput.addEventListener("keydown", (e) => {
			if (e.key === "Enter" && this.selectedFile) {
				this.close();
				this.onChooseFile(this.selectedFile);
			}
		});

		// Add button container with actions
		const buttonContainer = contentEl.createDiv();
		buttonContainer.style.display = "flex";
		buttonContainer.style.justifyContent = "flex-end";
		buttonContainer.style.marginTop = "10px";
		
		const insertButton = buttonContainer.createEl("button", { text: "Insert to Selected Note" });
		insertButton.addClass("mod-cta");
		insertButton.addEventListener("click", () => {
			this.close();
			this.onChooseFile(this.selectedFile);
		});
		
		// Add "Create New Note" button
		const newNoteButton = buttonContainer.createEl("button", { text: "Create New Note" });
		newNoteButton.style.marginRight = "10px";
		newNoteButton.addEventListener("click", () => {
			this.close();
			this.onChooseFile(null); // Signal to create a new note
		});
	}

	private displayFiles(files: TFile[]) {
		this.resultsContainer.empty();
		
		if (files.length === 0) {
			this.resultsContainer.createDiv({ text: "No matching notes found." });
			return;
		}

		files.forEach(file => {
			const fileEl = this.resultsContainer.createDiv("file-item");
			fileEl.style.display = "flex";
			fileEl.style.alignItems = "center";
			fileEl.style.padding = "6px";
			fileEl.style.borderBottom = "1px solid var(--background-modifier-border)";
			fileEl.style.cursor = "pointer";
			
			if (this.selectedFile && this.selectedFile.path === file.path) {
				fileEl.style.backgroundColor = "var(--background-modifier-active)";
			}
			
			// Add icon
			const iconEl = fileEl.createDiv();
			iconEl.style.marginRight = "8px";
			iconEl.setText("üìÑ");
			
			// Add path text
			const textEl = fileEl.createDiv();
			textEl.style.flex = "1";
			textEl.setText(file.path);
			
			// Add click event to select the file
			fileEl.addEventListener("click", () => {
				this.selectedFile = file;
				this.updateDisplay();
			});
		});
	}
	
	private updateDisplay() {
		// Refresh the display to show selection state
		const query = this.searchInput.value.toLowerCase();
		const currentFiles = this.allFiles.filter(file => 
			file.path.toLowerCase().includes(query)
		);
		this.displayFiles(currentFiles);
	}

	onClose() {
		const { contentEl } = this;
		contentEl.empty();
	}
}
